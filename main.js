/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MastermindPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/views/ChatView.ts
var import_obsidian4 = require("obsidian");

// src/services/vertex.ts
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var _VertexService = class {
  constructor(settings) {
    this.maxOutputTokens = 8192;
    this.temperature = 0.7;
    this.customContextPrompt = "";
    this.availableModels = [];
    // Permissions
    this.permVaultRead = true;
    this.permVaultWrite = true;
    this.permVaultDelete = false;
    this.permWeb = true;
    this.permTerminal = false;
    this.confirmVaultDestructive = true;
    this.confirmTerminalDestructive = true;
    // Token management (Vertex AI only)
    this.accessToken = null;
    this.tokenExpiry = 0;
    this.isRefreshingToken = false;
    this.tokenRefreshPromise = null;
    this.updateSettings(settings);
  }
  static getFallbackModelsFor(provider) {
    return provider === "aistudio" ? [..._VertexService.AI_STUDIO_FALLBACK_MODELS] : [..._VertexService.VERTEX_FALLBACK_MODELS];
  }
  updateSettings(settings) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    this.authProvider = (_a = settings.authProvider) != null ? _a : "vertex";
    this.serviceAccountJson = settings.serviceAccountJson;
    this.aiStudioKey = (_b = settings.aiStudioKey) != null ? _b : "";
    this.location = settings.location;
    this.modelId = settings.modelId;
    this.customContextPrompt = settings.customContextPrompt;
    this.availableModels = (_c = settings.availableModels) != null ? _c : [];
    this.maxOutputTokens = (_d = settings.maxOutputTokens) != null ? _d : 8192;
    this.temperature = (_e = settings.temperature) != null ? _e : 0.7;
    this.permVaultRead = (_f = settings.permVaultRead) != null ? _f : true;
    this.permVaultWrite = (_g = settings.permVaultWrite) != null ? _g : true;
    this.permVaultDelete = (_h = settings.permVaultDelete) != null ? _h : false;
    this.permWeb = (_i = settings.permWeb) != null ? _i : true;
    this.permTerminal = (_j = settings.permTerminal) != null ? _j : false;
    this.confirmVaultDestructive = (_k = settings.confirmVaultDestructive) != null ? _k : true;
    this.confirmTerminalDestructive = (_l = settings.confirmTerminalDestructive) != null ? _l : true;
    this.accessToken = null;
  }
  async getAccessToken() {
    if (this.accessToken && Date.now() < this.tokenExpiry) {
      return this.accessToken;
    }
    if (this.isRefreshingToken && this.tokenRefreshPromise) {
      return this.tokenRefreshPromise;
    }
    this.isRefreshingToken = true;
    this.tokenRefreshPromise = (async () => {
      try {
        if (!this.serviceAccountJson) {
          throw new Error("Service Account JSON not configured.");
        }
        let credentials;
        try {
          credentials = JSON.parse(this.serviceAccountJson);
        } catch (e) {
          throw new Error("Invalid Service Account JSON format.");
        }
        if (!credentials.client_email || !credentials.private_key) {
          throw new Error(
            "Service Account JSON missing client_email or private_key."
          );
        }
        const token = await this.createSignedJWT(
          credentials.client_email,
          credentials.private_key
        );
        const response = await (0, import_obsidian.requestUrl)({
          url: "https://oauth2.googleapis.com/token",
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${token}`
        });
        if (response.status !== 200) {
          throw new Error(`Failed to refresh token: ${response.text}`);
        }
        const data = response.json;
        this.accessToken = data.access_token;
        this.tokenExpiry = Date.now() + (data.expires_in - 120) * 1e3;
        return this.accessToken;
      } finally {
        this.isRefreshingToken = false;
        this.tokenRefreshPromise = null;
      }
    })();
    return this.tokenRefreshPromise;
  }
  async createSignedJWT(email, privateKeyPem) {
    const header = { alg: "RS256", typ: "JWT" };
    const now = Math.floor(Date.now() / 1e3);
    const claim = {
      iss: email,
      scope: "https://www.googleapis.com/auth/cloud-platform",
      aud: "https://oauth2.googleapis.com/token",
      exp: now + 3600,
      iat: now
    };
    const encodedHeader = this.base64url(JSON.stringify(header));
    const encodedClaim = this.base64url(JSON.stringify(claim));
    const unsignedToken = `${encodedHeader}.${encodedClaim}`;
    const signature = await this.sign(unsignedToken, privateKeyPem);
    return `${unsignedToken}.${signature}`;
  }
  base64url(source) {
    let encodedSource;
    if (typeof source === "string") {
      const bytes = new TextEncoder().encode(source);
      encodedSource = this.arrayBufferToBase64(bytes);
    } else {
      encodedSource = this.arrayBufferToBase64(source);
    }
    return encodedSource.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }
  async sign(data, privateKeyPem) {
    const pemHeader = "-----BEGIN PRIVATE KEY-----";
    const pemFooter = "-----END PRIVATE KEY-----";
    const pemContents = privateKeyPem.substring(
      privateKeyPem.indexOf(pemHeader) + pemHeader.length,
      privateKeyPem.indexOf(pemFooter)
    ).replace(/\s/g, "");
    const binaryDerString = window.atob(pemContents);
    const binaryDer = new Uint8Array(binaryDerString.length);
    for (let i = 0; i < binaryDerString.length; i++) {
      binaryDer[i] = binaryDerString.charCodeAt(i);
    }
    const crypto = window.crypto.subtle;
    const key = await crypto.importKey(
      "pkcs8",
      binaryDer.buffer,
      {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-256"
      },
      false,
      ["sign"]
    );
    const encoder = new TextEncoder();
    const dataBytes = encoder.encode(data);
    const signature = await crypto.sign("RSASSA-PKCS1-v1_5", key, dataBytes);
    return this.base64url(signature);
  }
  getProjectId() {
    try {
      return JSON.parse(this.serviceAccountJson).project_id;
    } catch (e) {
      return "";
    }
  }
  getBaseUrl(location) {
    const host = location === "global" ? "aiplatform.googleapis.com" : `${location}-aiplatform.googleapis.com`;
    return `https://${host}/v1/projects/${this.getProjectId()}/locations/${location}`;
  }
  getProviderFallbackModels() {
    return _VertexService.getFallbackModelsFor(this.authProvider);
  }
  mergeModelLists(primary, fallback) {
    const merged = [...primary];
    fallback.forEach((model) => {
      if (!merged.includes(model)) {
        merged.push(model);
      }
    });
    return merged;
  }
  setAvailableModelList(models) {
    const unique = Array.from(new Set(models.filter(Boolean)));
    this.availableModels = unique;
    if (unique.length > 0 && !unique.includes(this.modelId)) {
      this.modelId = unique[0];
    }
    return unique;
  }
  ensureModelSelection() {
    if (!this.availableModels || this.availableModels.length === 0) {
      this.availableModels = this.getProviderFallbackModels();
    }
    if (!this.modelId || !this.availableModels.includes(this.modelId)) {
      const fallback = this.getProviderFallbackModels();
      this.modelId = this.availableModels[0] || fallback[0] || _VertexService.VERTEX_FALLBACK_MODELS[0];
    }
    return this.modelId;
  }
  async listModels() {
    if (this.authProvider === "aistudio") {
      const fallback = this.getProviderFallbackModels();
      if (!this.aiStudioKey) {
        new import_obsidian.Notice(
          "Mastermind: AI Studio API key missing. Using default model list."
        );
        return this.setAvailableModelList(fallback);
      }
      try {
        const collected = [];
        let pageToken;
        do {
          const url = new URL(
            "https://generativelanguage.googleapis.com/v1beta/models"
          );
          url.searchParams.set("pageSize", "100");
          url.searchParams.set("key", this.aiStudioKey);
          if (pageToken) {
            url.searchParams.set("pageToken", pageToken);
          }
          const response = await (0, import_obsidian.requestUrl)({
            url: url.toString(),
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              "x-goog-api-key": this.aiStudioKey
            }
          });
          if (response.status !== 200 || !Array.isArray(response.json.models)) {
            console.warn(
              `Mastermind: AI Studio list models returned status ${response.status}`
            );
            break;
          }
          response.json.models.forEach((model) => {
            var _a;
            const name = (_a = model.name) == null ? void 0 : _a.split("/").pop();
            const supportsContent = Array.isArray(
              model.supportedGenerationMethods
            ) ? model.supportedGenerationMethods.some(
              (method) => [
                "generateContent",
                "generateMessage",
                "streamGenerateContent"
              ].includes(method)
            ) : true;
            if (name && !name.includes("embedding") && !name.includes("moderation") && supportsContent) {
              collected.push(name);
            }
          });
          pageToken = response.json.nextPageToken;
        } while (pageToken);
        const merged = collected.length > 0 ? this.mergeModelLists(collected, fallback) : fallback;
        new import_obsidian.Notice(`Mastermind: AI Studio models ready (${merged.length}).`);
        return this.setAvailableModelList(merged);
      } catch (error) {
        console.error("Mastermind: Error fetching AI Studio models", error);
      }
      new import_obsidian.Notice(
        "Mastermind: AI Studio model discovery failed. Using defaults."
      );
      return this.setAvailableModelList(fallback);
    }
    const accessToken = await this.getAccessToken();
    const projectId = this.getProjectId();
    const discoveryLocation = this.location === "global" || !this.location ? "us-central1" : this.location;
    new import_obsidian.Notice(
      `Mastermind: Discovering models... (Project: ${projectId}, Location: ${discoveryLocation})`
    );
    const fallbackModels = this.getProviderFallbackModels();
    const foundModels = /* @__PURE__ */ new Set();
    const safeFetch = async (url, label) => {
      try {
        console.log(`Mastermind: Fetching ${label} from ${url}`);
        const response = await (0, import_obsidian.requestUrl)({
          url,
          method: "GET",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "application/json"
          }
        });
        if (response.status === 200 && response.json.models) {
          return response.json.models;
        } else if (response.status === 200 && response.json.publisherModels) {
          return response.json.publisherModels;
        } else {
          console.warn(
            `Mastermind: ${label} returned status ${response.status}`
          );
          return [];
        }
      } catch (error) {
        console.error(`Mastermind: Error fetching ${label}:`, error);
        return [];
      }
    };
    const centralPublisherUrl = `https://us-central1-aiplatform.googleapis.com/v1/projects/${projectId}/locations/us-central1/publishers/google/models`;
    const centralPublisherModels = await safeFetch(
      centralPublisherUrl,
      "Publisher Models (us-central1)"
    );
    let publisherModels = [...centralPublisherModels];
    if (discoveryLocation !== "us-central1") {
      const regionalPublisherUrl = `https://${discoveryLocation}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${discoveryLocation}/publishers/google/models`;
      const regionalPublisherModels = await safeFetch(
        regionalPublisherUrl,
        `Publisher Models (${discoveryLocation})`
      );
      if (regionalPublisherModels.length === 0) {
        console.warn(
          `Mastermind: No publisher models discovered in ${discoveryLocation}. Using us-central1 list only.`
        );
      } else {
        publisherModels.push(...regionalPublisherModels);
      }
    }
    publisherModels.forEach((m) => {
      const name = m.name.split("/").pop();
      if (name.includes("gemini") || name.includes("bison") || name.includes("unicorn")) {
        foundModels.add(name);
      }
    });
    if (projectId) {
      const projectUrl = `https://${discoveryLocation}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${discoveryLocation}/models`;
      const projectModels = await safeFetch(projectUrl, "Project Models");
      projectModels.forEach((m) => {
        const name = m.name.split("/").pop();
        foundModels.add(name);
      });
    }
    if (foundModels.size === 0) {
      new import_obsidian.Notice(`Mastermind: No models found via API. Using fallback list.`);
      return this.setAvailableModelList(fallbackModels);
    }
    fallbackModels.forEach((m) => foundModels.add(m));
    const finalList = Array.from(foundModels).sort();
    new import_obsidian.Notice(
      `Mastermind: Discovery complete. Available models: ${finalList.length}`
    );
    return this.setAvailableModelList(finalList);
  }
  async *chat(prompt, context, vaultService, history = [], images = [], signal) {
    console.log("Mastermind: Service - chat called");
    const accessToken = await this.getAccessToken();
    console.log("Mastermind: Service - token retrieved");
    const projectId = JSON.parse(this.serviceAccountJson).project_id;
    const location = this.location || "us-central1";
    try {
      yield* this.chatInternal(
        prompt,
        context,
        vaultService,
        history,
        images,
        accessToken,
        projectId,
        location,
        "",
        "",
        0,
        signal
      );
    } catch (error) {
      if (signal == null ? void 0 : signal.aborted)
        return;
      const isConfigError = error.message.includes("404") || error.message.includes("not found") || error.message.includes("400");
      if (location !== "us-central1" && isConfigError) {
        console.log(
          `Mastermind: Chat failed in ${location} (Error: ${error.message}). Falling back to us-central1 + Safe Model...`
        );
        this.setAvailableModelList(this.getProviderFallbackModels());
        yield* this.chatInternal(
          prompt,
          context,
          vaultService,
          history,
          images,
          accessToken,
          projectId,
          "us-central1",
          "",
          "",
          0,
          signal
        );
      } else if (error.message.includes("400")) {
        console.log(
          "Mastermind: 400 Bad Request. Retrying with provider fallback model..."
        );
        this.setAvailableModelList(this.getProviderFallbackModels());
        yield* this.chatInternal(
          prompt,
          context,
          vaultService,
          history,
          images,
          accessToken,
          projectId,
          location,
          "",
          "",
          0,
          signal
        );
      } else {
        throw error;
      }
    }
  }
  async *chatInternal(prompt, context, vaultService, history = [], images = [], accessToken, projectId, location, initialText = "", initialThinking = "", recursionDepth = 0, signal) {
    var _a, _b;
    if (recursionDepth > 30) {
      yield {
        text: "\n\n**Error:** Max recursion limit reached (30 steps). The model is looping or the task is too complex.",
        actions: []
      };
      return;
    }
    if (signal == null ? void 0 : signal.aborted) {
      throw new Error("AbortError");
    }
    const modelId = this.ensureModelSelection();
    const isClaude = modelId.startsWith("claude");
    const isEndpoint = /^\d+$/.test(modelId) || modelId.includes("/endpoints/");
    const effectiveLocation = location || "us-central1";
    if (isEndpoint || isClaude || modelId.includes("imagen")) {
      let url2 = "";
      let body2 = {};
      if (isEndpoint) {
        const endpointResource = modelId.includes("/") ? modelId : `projects/${projectId}/locations/${effectiveLocation}/endpoints/${modelId}`;
        const host = effectiveLocation === "global" ? "aiplatform.googleapis.com" : `${effectiveLocation}-aiplatform.googleapis.com`;
        const useSSE = !isEndpoint;
        url2 = `https://${host}/v1/${endpointResource}:${isEndpoint ? "predict" : "streamGenerateContent"}${useSSE ? "?alt=sse" : ""}`;
        body2 = {
          instances: [
            {
              prompt: `System: You are Mastermind.
Context: ${context}

User: ${prompt}
Assistant:`
            }
          ],
          parameters: {
            temperature: this.temperature,
            maxOutputTokens: this.maxOutputTokens,
            topP: 0.95
          }
        };
      } else if (isClaude) {
        url2 = `${this.getBaseUrl(effectiveLocation)}/publishers/anthropic/models/${modelId}:streamRawPredict`;
        const messages = history.map((h) => ({
          role: h.role === "model" ? "assistant" : "user",
          content: h.parts[0].text
        }));
        messages.push({
          role: "user",
          content: `Context:
${context}

Question: ${prompt}`
        });
        body2 = {
          anthropic_version: "vertex-2023-10-16",
          messages,
          system: `You are Mastermind. ${this.customContextPrompt || ""} Be concise.`,
          max_tokens: this.maxOutputTokens,
          temperature: this.temperature,
          stream: false
        };
      } else {
        url2 = `${this.getBaseUrl(effectiveLocation)}/publishers/google/models/${modelId}:predict`;
        body2 = {
          instances: [{ prompt }],
          parameters: { sampleCount: 1 }
        };
        new import_obsidian.Notice("Mastermind: Generating image...");
      }
      const response = await (0, import_obsidian.requestUrl)({
        url: url2,
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body2)
      });
      if (response.status !== 200)
        throw new Error(`API Error ${response.status}: ${response.text}`);
      const data = response.json;
      if (modelId.includes("imagen")) {
        if ((_b = (_a = data.predictions) == null ? void 0 : _a[0]) == null ? void 0 : _b.bytesBase64Encoded) {
          const link = await vaultService.saveImage(
            data.predictions[0].bytesBase64Encoded
          );
          yield {
            text: `Here is your generated image:

${link}`,
            actions: []
          };
          return;
        }
        throw new Error("No image data returned.");
      }
      const text = isEndpoint ? data.predictions[0].content : data.content ? data.content[0].text : JSON.stringify(data);
      yield { text, actions: [] };
      return;
    }
    const isGemini3 = modelId.includes("gemini-3");
    const apiVersion = isGemini3 || modelId.includes("preview") || modelId.includes("exp") || modelId.includes("beta") ? "v1beta1" : "v1";
    const runLocation = isGemini3 ? "global" : effectiveLocation;
    let url;
    let authHeaders;
    if (this.authProvider === "aistudio") {
      url = `https://generativelanguage.googleapis.com/${apiVersion}/models/${modelId}:streamGenerateContent?alt=sse&key=${encodeURIComponent(this.aiStudioKey)}`;
      authHeaders = {
        "Content-Type": "application/json",
        "x-goog-api-key": this.aiStudioKey
      };
    } else {
      url = `${this.getBaseUrl(runLocation).replace("/v1/", `/${apiVersion}/`)}/publishers/google/models/${modelId}:streamGenerateContent?alt=sse`;
      authHeaders = {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`
      };
    }
    let systemInstructionText = `You are "Mastermind", a highly capable AI assistant for Obsidian.
You have access to the user's notes and knowledge vault.
Be concise, professional, and insightful.
Always use the provided context to answer questions if available.
You can use tools to search, read, list, create, and delete notes/folders in the vault.

IMPORTANT: If you need to reason through a complex problem, show your work by wrapping your thought process in a "thinking" code block, like this:
\`\`\`thinking
My reasoning process...
\`\`\`
Then provide your final answer.`;
    if (this.customContextPrompt) {
      systemInstructionText += `

USER CUSTOM INSTRUCTIONS:
${this.customContextPrompt}`;
    }
    const tools = [
      {
        functionDeclarations: [
          {
            name: "generate_image",
            description: "Generates an image based on a prompt using Imagen 3. Use this when the user asks to draw, paint, or create an image.",
            parameters: {
              type: "object",
              properties: {
                prompt: {
                  type: "string",
                  description: "The visual description of the image to generate."
                }
              },
              required: ["prompt"]
            }
          },
          {
            name: "list_files",
            description: "Lists all markdown files in the vault.",
            parameters: { type: "object", properties: {} }
          },
          {
            name: "list_directory",
            description: "Lists the contents of a specific directory/folder.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The path of the folder to list."
                }
              },
              required: ["path"]
            }
          },
          {
            name: "read_file",
            description: "Reads the full content of a specified markdown file.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The absolute path of the file to read."
                }
              },
              required: ["path"]
            }
          },
          {
            name: "search_content",
            description: "Searches for a keyword or phrase within all markdown files in the vault.",
            parameters: {
              type: "object",
              properties: {
                query: { type: "string", description: "The search term." }
              },
              required: ["query"]
            }
          },
          {
            name: "create_note",
            description: "Creates a new markdown note with the specified content.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: 'The path for the new note (e.g., "Summaries/MyNote.md").'
                },
                content: {
                  type: "string",
                  description: "The content of the note."
                }
              },
              required: ["path", "content"]
            }
          },
          {
            name: "create_folder",
            description: "Creates a new folder.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The path for the new folder."
                }
              },
              required: ["path"]
            }
          },
          {
            name: "delete_file",
            description: "Deletes a file or folder. Use with caution.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The path of the file to delete."
                }
              },
              required: ["path"]
            }
          },
          {
            name: "move_file",
            description: "Moves or renames a file or folder.",
            parameters: {
              type: "object",
              properties: {
                oldPath: { type: "string", description: "The current path." },
                newPath: { type: "string", description: "The new path." }
              },
              required: ["oldPath", "newPath"]
            }
          },
          {
            name: "run_terminal_command",
            description: "Executes a shell command on the host OS. Use with caution.",
            parameters: {
              type: "object",
              properties: {
                command: {
                  type: "string",
                  description: "The shell command to execute."
                }
              },
              required: ["command"]
            }
          },
          {
            name: "fetch_url",
            description: "Fetches the content of a URL. Useful for reading documentation or articles.",
            parameters: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "The absolute URL to fetch."
                }
              },
              required: ["url"]
            }
          },
          {
            name: "append_to_note",
            description: "Appends content to the end of a note.",
            parameters: {
              type: "object",
              properties: {
                path: { type: "string" },
                content: { type: "string" }
              },
              required: ["path", "content"]
            }
          },
          {
            name: "prepend_to_note",
            description: "Prepends content to the start of a note (after frontmatter if present).",
            parameters: {
              type: "object",
              properties: {
                path: { type: "string" },
                content: { type: "string" }
              },
              required: ["path", "content"]
            }
          },
          {
            name: "update_section",
            description: "Updates a specific section of a note under a given header.",
            parameters: {
              type: "object",
              properties: {
                path: { type: "string" },
                header: {
                  type: "string",
                  description: "The exact header text (without #)"
                },
                content: {
                  type: "string",
                  description: "The new content for the section"
                }
              },
              required: ["path", "header", "content"]
            }
          },
          {
            name: "get_tags",
            description: "Gets all unique tags in the vault.",
            parameters: { type: "object", properties: {} }
          },
          {
            name: "get_links",
            description: "Gets all outgoing links from a specific note.",
            parameters: {
              type: "object",
              properties: { path: { type: "string" } },
              required: ["path"]
            }
          }
        ]
      },
      {
        googleSearch: {}
      }
    ];
    let contents = history.map((item) => ({
      role: item.role,
      parts: item.parts
    }));
    const pParts = [
      { text: `Context from vault:
${context}

User Question: ${prompt}` }
    ];
    for (const img of images) {
      pParts.push({ inlineData: { mimeType: img.mimeType, data: img.data } });
    }
    contents.push({ role: "user", parts: pParts });
    const body = {
      contents,
      system_instruction: { parts: [{ text: systemInstructionText }] },
      tools,
      generationConfig: {
        temperature: this.temperature,
        maxOutputTokens: this.maxOutputTokens
      },
      safetySettings: [
        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_ONLY_HIGH" },
        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_ONLY_HIGH" },
        {
          category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          threshold: "BLOCK_ONLY_HIGH"
        },
        {
          category: "HARM_CATEGORY_DANGEROUS_CONTENT",
          threshold: "BLOCK_ONLY_HIGH"
        }
      ]
    };
    console.log(`Mastermind: Starting stream request to ${url}`);
    let stream;
    try {
      stream = this.streamRequest(url, {
        method: "POST",
        headers: authHeaders,
        body: JSON.stringify(body),
        signal
      });
    } catch (e) {
      console.error("Mastermind: Failed to initiate stream", e);
      throw e;
    }
    let buffer = "";
    let accumulatedText = initialText;
    let accumulatedThinking = initialThinking;
    let isThinking = false;
    let accumulatedFunctions = [];
    try {
      let buffer2 = "";
      for await (const chunk of stream) {
        buffer2 += chunk;
        let boundary = buffer2.indexOf("\n");
        while (boundary !== -1) {
          const line = buffer2.substring(0, boundary).trim();
          buffer2 = buffer2.substring(boundary + 1);
          boundary = buffer2.indexOf("\n");
          if (!line || line.startsWith(":"))
            continue;
          const jsonStr = line.replace(/^data:\s*/, "").trim();
          if (!jsonStr)
            continue;
          try {
            const data = JSON.parse(jsonStr);
            const candidates = data.candidates;
            if (candidates && candidates[0]) {
              const candidate = candidates[0];
              if (candidate.content && candidate.content.parts) {
                for (const part of candidate.content.parts) {
                  if (part.text) {
                    let textPart = part.text;
                    let remaining = textPart;
                    while (remaining.length > 0) {
                      if (!isThinking) {
                        const match = remaining.match(/```thinking/i);
                        if (match && match.index !== void 0) {
                          const startIdx = match.index;
                          accumulatedText += remaining.substring(0, startIdx);
                          remaining = remaining.substring(
                            startIdx + match[0].length
                          );
                          isThinking = true;
                          console.log("Mastermind: Thinking block STARTED");
                        } else {
                          accumulatedText += remaining;
                          remaining = "";
                        }
                      } else {
                        const endIdx = remaining.indexOf("```");
                        if (endIdx !== -1) {
                          const thoughtChunk = remaining.substring(0, endIdx);
                          accumulatedThinking += thoughtChunk;
                          remaining = remaining.substring(endIdx + 3);
                          isThinking = false;
                          console.log(
                            "Mastermind: Thinking block ENDED. Content length:",
                            thoughtChunk.length
                          );
                        } else {
                          accumulatedThinking += remaining;
                          remaining = "";
                        }
                      }
                    }
                    yield {
                      text: accumulatedText,
                      isThinking,
                      thinkingText: accumulatedThinking,
                      actions: []
                    };
                  } else if (part.functionCall) {
                    accumulatedFunctions.push(part.functionCall);
                  }
                }
              }
            }
          } catch (e) {
          }
        }
      }
    } catch (e) {
      console.error("Mastermind: Streaming Loop Error", e);
      throw e;
    }
    if (accumulatedFunctions.length > 0) {
      const functionResponseParts = [];
      const executedActions = [];
      const modelParts = [];
      if (accumulatedText && accumulatedText.trim()) {
        modelParts.push({ text: accumulatedText });
      }
      for (const fc of accumulatedFunctions) {
        modelParts.push({ functionCall: fc });
      }
      contents.push({ role: "model", parts: modelParts });
      for (const funcCall of accumulatedFunctions) {
        const { name, args } = funcCall;
        let result;
        yield {
          text: accumulatedText,
          thinkingText: accumulatedThinking,
          actions: [{ tool: name, input: args, status: "pending" }]
        };
        try {
          if (name === "generate_image") {
            new import_obsidian.Notice(
              `Mastermind: Switching to Imagen 3 for "${args.prompt}"...`
            );
            const imagenLink = await this.generateImageInternal(
              args.prompt,
              accessToken,
              projectId,
              location,
              vaultService
            );
            result = {
              status: "success",
              image_link: imagenLink,
              message: "Image generated successfully."
            };
          } else if (name === "list_files" || name === "read_file" || name === "search_content" || name === "list_directory" || name === "get_tags" || name === "get_links") {
            if (!this.permVaultRead) {
              result = {
                status: "error",
                message: "Permission denied: Vault read access is disabled in settings."
              };
            } else {
              if (name === "list_files") {
                result = await vaultService.listMarkdownFiles();
              } else if (name === "read_file") {
                result = await vaultService.getFileContent(args.path);
              } else if (name === "search_content") {
                result = await vaultService.searchVault(args.query);
              } else if (name === "list_directory") {
                result = await vaultService.listFolder(args.path);
              } else if (name === "get_tags") {
                const tags = await vaultService.getTags();
                result = { status: "success", tags };
              } else if (name === "get_links") {
                const links = await vaultService.getLinks(args.path);
                result = { status: "success", links };
              }
            }
          } else if (name === "create_note" || name === "create_folder" || name === "move_file" || name === "append_to_note" || name === "prepend_to_note" || name === "update_section") {
            if (!this.permVaultWrite) {
              result = {
                status: "error",
                message: "Permission denied: Vault write access is disabled in settings."
              };
            } else {
              if (name === "create_note") {
                await vaultService.createNote(args.path, args.content);
                result = {
                  status: "success",
                  message: `Note created at ${args.path}`
                };
              } else if (name === "create_folder") {
                await vaultService.createFolder(args.path);
                result = {
                  status: "success",
                  message: `Folder created at ${args.path}`
                };
              } else if (name === "move_file") {
                await vaultService.moveFile(args.oldPath, args.newPath);
                result = {
                  status: "success",
                  message: `Moved ${args.oldPath} to ${args.newPath}`
                };
              } else if (name === "append_to_note") {
                await vaultService.appendToNote(args.path, args.content);
                result = {
                  status: "success",
                  message: `Appended content to ${args.path}`
                };
              } else if (name === "prepend_to_note") {
                await vaultService.prependToNote(args.path, args.content);
                result = {
                  status: "success",
                  message: `Prepended content to ${args.path}`
                };
              } else if (name === "update_section") {
                await vaultService.updateNoteSection(
                  args.path,
                  args.header,
                  args.content
                );
                result = {
                  status: "success",
                  message: `Updated section "${args.header}" in ${args.path}`
                };
              }
            }
          } else if (name === "delete_file") {
            if (!this.permVaultDelete) {
              result = {
                status: "error",
                message: "Permission denied: Vault delete access is disabled in settings."
              };
            } else {
              if (this.confirmVaultDestructive && vaultService.app.plugins.getPlugin(
                "obsidian-vertex-ai-mastermind"
              ).settings.confirmVaultDestructive) {
                result = {
                  status: "error",
                  message: "Vault deletions require confirmation. Please enable this manually or disable confirmation in settings."
                };
              } else {
                await vaultService.deleteFile(args.path);
                result = {
                  status: "success",
                  message: `File deleted at ${args.path}`
                };
              }
            }
          } else if (name === "run_terminal_command") {
            if (!this.permTerminal) {
              result = {
                status: "error",
                message: "Permission denied: Terminal access is disabled in settings."
              };
            } else {
              if (this.confirmTerminalDestructive && vaultService.app.plugins.getPlugin(
                "obsidian-vertex-ai-mastermind"
              ).settings.confirmTerminalDestructive) {
                result = {
                  status: "error",
                  message: "Terminal commands require confirmation. Disable confirmation in settings."
                };
              } else {
                try {
                  const { stdout, stderr } = await execAsync(args.command);
                  result = {
                    status: "success",
                    stdout,
                    stderr
                  };
                } catch (e) {
                  result = {
                    status: "error",
                    message: e.message,
                    stderr: e.stderr
                  };
                }
              }
            }
          } else if (name === "fetch_url") {
            if (!this.permWeb) {
              result = {
                status: "error",
                message: "Permission denied: Web access is disabled in settings."
              };
            } else {
              try {
                const response = await (0, import_obsidian.requestUrl)({ url: args.url });
                const text = response.text.substring(0, 1e4);
                result = {
                  status: "success",
                  content_snippet: text,
                  full_length: response.text.length
                };
              } catch (e) {
                result = { status: "error", message: e.message };
              }
            }
          } else {
            result = { status: "error", message: `Unknown tool: ${name}` };
          }
        } catch (e) {
          result = { status: "error", message: e.message };
        }
        executedActions.push({
          tool: name,
          input: args,
          output: result,
          status: result.status
        });
        functionResponseParts.push({
          functionResponse: { name, response: { content: result } }
        });
      }
      contents.push({ role: "user", parts: functionResponseParts });
      yield* this.chatInternal(
        prompt,
        context,
        vaultService,
        contents,
        [],
        accessToken,
        projectId,
        location,
        accumulatedText,
        accumulatedThinking,
        recursionDepth + 1,
        signal
      );
    }
  }
  // Helper: Generate Image (Imagen 3)
  async generateImageInternal(prompt, accessToken, projectId, location, vaultService) {
    const modelId = "imagen-3.0-generate-001";
    const url = `${this.getBaseUrl(location)}/publishers/google/models/${modelId}:predict`;
    const body = {
      instances: [{ prompt }],
      parameters: {
        sampleCount: 1
      }
    };
    const response = await (0, import_obsidian.requestUrl)({
      url,
      method: "POST",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if (response.status !== 200) {
      throw new Error(`Imagen Error ${response.status}: ${response.text}`);
    }
    const data = response.json;
    if (data.predictions && data.predictions.length > 0 && data.predictions[0].bytesBase64Encoded) {
      const base64 = data.predictions[0].bytesBase64Encoded;
      return await vaultService.saveImage(base64);
    }
    throw new Error("No image data returned from Imagen.");
  }
  // Node.js HTTPS Streaming Helper
  async *streamRequest(urlStr, options) {
    const https = require("https");
    const { URL: URL2 } = require("url");
    const url = new URL2(urlStr);
    const reqOptions = {
      hostname: url.hostname,
      port: 443,
      path: url.pathname + url.search,
      method: options.method,
      headers: options.headers,
      signal: options.signal
    };
    const queue = new AsyncQueue();
    const req = https.request(reqOptions, (res) => {
      if (res.statusCode && res.statusCode >= 300) {
        let errorBody = "";
        res.setEncoding("utf8");
        res.on("data", (chunk) => {
          errorBody += chunk;
        });
        res.on("end", () => {
          console.error(
            `Mastermind: HTTPS Error ${res.statusCode} Body:`,
            errorBody
          );
          queue.fail(new Error(`HTTP Error ${res.statusCode}: ${errorBody}`));
        });
        return;
      }
      res.setEncoding("utf8");
      res.on("data", (chunk) => {
        console.log(`Mastermind: HTTPS chunk received (${chunk.length} bytes)`);
        queue.push(chunk);
      });
      res.on("end", () => {
        console.log("Mastermind: HTTPS stream ended");
        queue.close();
      });
      res.on("error", (err) => {
        console.error("Mastermind: HTTPS stream error", err);
        queue.fail(err);
      });
    });
    req.on("error", (err) => queue.fail(err));
    req.write(options.body);
    req.end();
    yield* queue;
  }
  // Helper method to validate JSON
  validateJSON(json) {
    try {
      JSON.parse(json);
      return true;
    } catch (e) {
      return false;
    }
  }
  // End of class
};
var VertexService = _VertexService;
VertexService.VERTEX_FALLBACK_MODELS = [
  "gemini-2.0-flash-001",
  "gemini-2.0-flash-lite-preview-02-05",
  "gemini-2.0-pro-exp-02-05",
  "gemini-1.5-pro",
  "gemini-1.5-flash",
  "gemini-3-pro-preview",
  "gemini-3-flash-preview",
  "gemini-2.0-flash-thinking-exp-01-21",
  "imagen-3.0-generate-001",
  "imagen-3.0-fast-generate-001"
];
VertexService.AI_STUDIO_FALLBACK_MODELS = [
  "gemini-2.0-flash-001",
  "gemini-2.0-flash-lite-preview-02-05",
  "gemini-1.5-pro",
  "gemini-1.5-flash",
  "gemini-2.0-pro-exp-02-05",
  "gemini-2.0-flash-thinking-exp-01-21"
];
var AsyncQueue = class {
  constructor() {
    this.queue = [];
    this.resolveNext = null;
    this.rejectNext = null;
    this.closed = false;
    this.error = null;
  }
  push(value) {
    if (this.closed)
      return;
    if (this.resolveNext) {
      const resolve = this.resolveNext;
      this.resolveNext = null;
      this.rejectNext = null;
      resolve({ value, done: false });
    } else {
      this.queue.push(value);
    }
  }
  close() {
    this.closed = true;
    if (this.resolveNext) {
      const resolve = this.resolveNext;
      this.resolveNext = null;
      this.rejectNext = null;
      resolve({ value: void 0, done: true });
    }
  }
  fail(err) {
    this.error = err;
    if (this.rejectNext) {
      const reject = this.rejectNext;
      this.resolveNext = null;
      this.rejectNext = null;
      reject(err);
    }
  }
  [Symbol.asyncIterator]() {
    return {
      next: () => {
        if (this.error)
          return Promise.reject(this.error);
        if (this.queue.length > 0) {
          return Promise.resolve({ value: this.queue.shift(), done: false });
        }
        if (this.closed) {
          return Promise.resolve({ value: void 0, done: true });
        }
        return new Promise((resolve, reject) => {
          this.resolveNext = resolve;
          this.rejectNext = reject;
        });
      }
    };
  }
};

// src/services/vault.ts
var import_obsidian2 = require("obsidian");
var VaultService = class {
  constructor(app) {
    this.app = app;
  }
  async getRelevantContext(query) {
    const activeFile = this.app.workspace.getActiveFile();
    let context = "";
    if (activeFile) {
      const content = await this.app.vault.read(activeFile);
      context += `--- ACTIVE FILE: ${activeFile.path} ---
${content}

`;
    }
    const files = this.app.vault.getMarkdownFiles();
    const queryLower = query.toLowerCase();
    const scores = await Promise.all(files.map(async (file) => {
      let score = 0;
      if (file.name.toLowerCase().includes(queryLower))
        score += 10;
      if (file.path.toLowerCase().includes(queryLower))
        score += 5;
      const content = await this.app.vault.read(file);
      const contentSnippet = content.substring(0, 5e3).toLowerCase();
      if (contentSnippet.includes(queryLower))
        score += 20;
      return { file, score };
    }));
    const relevantFiles = scores.filter((item) => item.score > 5).sort((a, b) => b.score - a.score).slice(0, 5);
    for (const item of relevantFiles) {
      if (item.file.path === (activeFile == null ? void 0 : activeFile.path))
        continue;
      const content = await this.app.vault.read(item.file);
      context += `--- RELEVANT FILE: ${item.file.path} ---
${content.substring(0, 2e3)}...

`;
    }
    return context || "No immediate relevant context found. Mastermind may need to search the vault.";
  }
  async listMarkdownFiles() {
    return this.app.vault.getMarkdownFiles().map((f) => f.path);
  }
  async getFileContent(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian2.TFile) {
      return await this.app.vault.read(file);
    }
    throw new Error(`File not found or not a markdown file: ${path}`);
  }
  async getActiveNoteImages() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return [];
    const content = await this.app.vault.read(activeFile);
    const imageExtensions = ["png", "jpg", "jpeg", "gif", "webp"];
    const images = [];
    const wikilinkRegex = /!\[\[([^\]]+\.(?:png|jpg|jpeg|gif|webp))\]\]/gi;
    const mdlinkRegex = /!\[(?:[^\]]*)\]\(([^)]+\.(?:png|jpg|jpeg|gif|webp))\)/gi;
    const findImages = async (regex, content2) => {
      let match;
      while ((match = regex.exec(content2)) !== null) {
        const link = match[1];
        const file = this.app.metadataCache.getFirstLinkpathDest(link, activeFile.path);
        if (file instanceof import_obsidian2.TFile && imageExtensions.includes(file.extension.toLowerCase())) {
          const buffer = await this.app.vault.readBinary(file);
          const base64 = this.arrayBufferToBase64(buffer);
          const mimeType = `image/${file.extension === "jpg" ? "jpeg" : file.extension}`;
          images.push({ mimeType, data: base64 });
        }
      }
    };
    await findImages(wikilinkRegex, content);
    await findImages(mdlinkRegex, content);
    return images;
  }
  arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }
  async searchVault(query) {
    const queryLower = query.toLowerCase();
    const files = this.app.vault.getMarkdownFiles();
    const results = [];
    for (const file of files) {
      const content = await this.app.vault.read(file);
      if (content.toLowerCase().includes(queryLower) || file.path.toLowerCase().includes(queryLower)) {
        results.push(file.path);
      }
      if (results.length >= 20)
        break;
    }
    return results;
  }
  async createFolder(path) {
    if (!await this.app.vault.adapter.exists(path)) {
      await this.app.vault.createFolder(path);
    }
  }
  async createNote(path, content) {
    const normalizedPath = path.endsWith(".md") ? path : `${path}.md`;
    const folders = normalizedPath.split("/").slice(0, -1);
    if (folders.length > 0) {
      const folderPath = folders.join("/");
      await this.ensureFoldersExist(folderPath);
    }
    if (await this.app.vault.adapter.exists(normalizedPath)) {
      const file = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (file instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(file, content);
        return;
      }
    }
    await this.app.vault.create(normalizedPath, content);
  }
  async ensureFoldersExist(path) {
    const dirs = path.split("/");
    let currentPath = "";
    for (const dir of dirs) {
      currentPath = currentPath === "" ? dir : `${currentPath}/${dir}`;
      if (!await this.app.vault.adapter.exists(currentPath)) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  async deleteFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file) {
      await this.app.vault.delete(file, true);
    } else {
      throw new Error(`File to delete not found: ${path}`);
    }
  }
  async getAllFileNames() {
    const files = this.app.vault.getMarkdownFiles();
    const fileNames = /* @__PURE__ */ new Set();
    for (const file of files) {
      if (file.basename) {
        fileNames.add(file.basename);
      }
    }
    return fileNames;
  }
  async writeHistory(history, sessionId) {
    const historyFolder = "Mastermind/History";
    await this.ensureFoldersExist(historyFolder);
    let filename = sessionId;
    if (!filename) {
      const now = new Date();
      filename = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")}-${String(now.getHours()).padStart(2, "0")}-${String(now.getMinutes()).padStart(2, "0")}-${String(now.getSeconds()).padStart(2, "0")}`;
    }
    if (!filename.endsWith(".md"))
      filename += ".md";
    const path = `${historyFolder}/${filename}`;
    let content = "# Mastermind Conversation\n\n";
    history.forEach((msg) => {
      const role = msg.role === "user" ? "User" : "Mastermind";
      const text = msg.parts.map((p) => p.text).join("\n");
      content += `> **${role}**
${text}

`;
    });
    content += `
*Auto-saved at ${new Date().toISOString()}*`;
    await this.createOrUpdateNote(path, content);
    return filename.replace(".md", "");
  }
  async listFolder(path) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (!folder || !folder.children) {
      throw new Error(`Folder not found: ${path}`);
    }
    return folder.children.map((child) => child.path);
  }
  async moveFile(oldPath, newPath) {
    const file = this.app.vault.getAbstractFileByPath(oldPath);
    if (!file) {
      throw new Error(`File or folder not found: ${oldPath}`);
    }
    const folders = newPath.split("/").slice(0, -1);
    if (folders.length > 0) {
      await this.ensureFoldersExist(folders.join("/"));
    }
    if (await this.app.vault.adapter.exists(newPath)) {
      throw new Error(`A file or folder already exists at the destination path: ${newPath}`);
    }
    await this.app.vault.rename(file, newPath);
  }
  // Improved Implementation: createOrUpdateNote
  async createOrUpdateNote(path, content) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(file, content);
    } else {
      const lastSlash = path.lastIndexOf("/");
      if (lastSlash !== -1) {
        await this.ensureFoldersExist(path.substring(0, lastSlash));
      }
      await this.app.vault.create(path, content);
    }
  }
  async writeLog(message) {
    const logPath = "Mastermind/Logs/debug.md";
    let currentContent = "";
    try {
      currentContent = await this.getFileContent(logPath);
    } catch (e) {
      currentContent = "# Mastermind Debug Logs\n\n";
    }
    const timestamp = new Date().toISOString();
    const newContent = `${currentContent}
[${timestamp}] ${message}
`;
    await this.createOrUpdateNote(logPath, newContent);
  }
  async saveImage(base64Data) {
    const folder = "Mastermind_Images";
    await this.ensureFoldersExist(folder);
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const filename = `Generated-${timestamp}.png`;
    const filepath = `${folder}/${filename}`;
    const buffer = this.base64ToArrayBuffer(base64Data);
    if (await this.app.vault.adapter.exists(filepath)) {
    }
    await this.app.vault.createBinary(filepath, buffer);
    return `![Generated Image](${filepath})`;
  }
  base64ToArrayBuffer(base64) {
    const binaryString = window.atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
  async enhanceTextWithLinks(text) {
    const fileNames = await this.getAllFileNames();
    const sortedNames = Array.from(fileNames).sort((a, b) => b.length - a.length);
    let processedText = text;
    for (const name of sortedNames) {
      if (name.length < 3)
        continue;
      const regex = new RegExp(`(?<!\\[\\[)\\b(${this.escapeRegExp(name)})\\b(?!\\]\\])`, "g");
      processedText = processedText.replace(regex, "[[$1]]");
    }
    return processedText;
  }
  async appendToNote(path, content) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.process(file, (data) => {
        return data + ((data.endsWith("\n") ? "" : "\n") + content);
      });
    } else {
      throw new Error(`File not found: ${path}`);
    }
  }
  async prependToNote(path, content) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.process(file, (data) => {
        const frontmatterRegex = /^---\n[\s\S]*?\n---\n/;
        const match = data.match(frontmatterRegex);
        if (match) {
          return data.slice(0, match[0].length) + content + "\n" + data.slice(match[0].length);
        } else {
          return content + "\n" + data;
        }
      });
    } else {
      throw new Error(`File not found: ${path}`);
    }
  }
  async updateNoteSection(path, header, newContent) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian2.TFile))
      throw new Error(`File not found: ${path}`);
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.headings)
      throw new Error(`No metadata/headings found for ${path}`);
    const targetHeading = cache.headings.find((h) => h.heading === header);
    if (!targetHeading)
      throw new Error(`Heading "${header}" not found in ${path}`);
    const headings = cache.headings;
    const targetIndex = headings.indexOf(targetHeading);
    let endLine = -1;
    for (let i = targetIndex + 1; i < headings.length; i++) {
      if (headings[i].level <= targetHeading.level) {
        endLine = headings[i].position.start.line;
        break;
      }
    }
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const startLine = targetHeading.position.end.line + 1;
    const actualEndLine = endLine === -1 ? lines.length : endLine;
    const newLines = [
      ...lines.slice(0, startLine),
      newContent,
      ...lines.slice(actualEndLine)
    ];
    await this.app.vault.modify(file, newLines.join("\n"));
  }
  async getTags() {
    const tags = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache) {
        const fileTags = (0, import_obsidian2.getAllTags)(cache);
        if (fileTags) {
          fileTags.forEach((t) => tags.add(t));
        }
      }
    }
    return Array.from(tags).sort();
  }
  async getLinks(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian2.TFile))
      throw new Error(`File not found: ${path}`);
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.links)
      return [];
    return cache.links.map((l) => l.link);
  }
  // Helper for internal use if needed
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};

// src/views/MessageRenderer.ts
var import_obsidian3 = require("obsidian");
var MessageRenderer = class {
  constructor(app, container) {
    this.app = app;
    this.container = container;
  }
  renderTo(container) {
    this.container = container;
  }
  async renderUserMessage(text, avatarUrl) {
    const msgBlock = this.container.createDiv("chat-message-block message-block-user");
    const avatar = msgBlock.createEl("img", { cls: "chat-avatar", attr: { src: avatarUrl } });
    const msgEl = msgBlock.createDiv("chat-message message-user");
    msgEl.innerText = text;
    this.scrollBottom();
    return msgEl;
  }
  async renderAIMessage(text, avatarUrl, actions = []) {
    const msgBlock = this.container.createDiv("chat-message-block message-block-ai");
    const avatar = msgBlock.createEl("img", { cls: "chat-avatar", attr: { src: avatarUrl } });
    const contentContainer = msgBlock.createDiv("chat-message-content message-ai");
    if (actions && actions.length > 0) {
      await this.renderToolActions(contentContainer, actions);
    }
    if (text) {
      const msgEl = contentContainer.createDiv("chat-text-content");
      const component = new import_obsidian3.Component();
      component.load();
      await import_obsidian3.MarkdownRenderer.render(this.app, text, msgEl, "", component);
    }
    this.scrollBottom();
    return contentContainer;
  }
  startAIMessage(avatarUrl) {
    const msgBlock = this.container.createDiv("chat-message-block message-block-ai");
    const avatar = msgBlock.createEl("img", { cls: "chat-avatar", attr: { src: avatarUrl } });
    const contentContainer = msgBlock.createDiv("chat-message-content message-ai");
    const toolContainer = contentContainer.createDiv("chat-tool-actions");
    const thinkingContainer = contentContainer.createDiv("thinking-container");
    thinkingContainer.style.display = "none";
    const thinkingHeader = thinkingContainer.createDiv("thinking-header");
    (0, import_obsidian3.setIcon)(thinkingHeader.createSpan("thinking-icon"), "brain-circuit");
    thinkingHeader.createSpan().innerText = "Thinking Process";
    const dotsContainer = thinkingContainer.createDiv("thinking-dots");
    dotsContainer.innerHTML = '<div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div>';
    const thinkingContent = thinkingContainer.createDiv("thinking-content");
    thinkingContent.style.display = "none";
    const textContainer = contentContainer.createDiv("chat-text-content");
    let fullTextToRender = "";
    let fullThinkingText = "";
    let displayedTextLength = 0;
    let isRendering = false;
    let typeWriterInterval = null;
    const processTypewriterQueue = async () => {
      if (isRendering)
        return;
      isRendering = true;
      const targetLength = fullTextToRender.length;
      if (displayedTextLength < targetLength) {
        const backlog = targetLength - displayedTextLength;
        const charsToAdd = backlog > 50 ? 5 : backlog > 20 ? 2 : 1;
        const nextChunk = fullTextToRender.substring(displayedTextLength, displayedTextLength + charsToAdd);
        displayedTextLength += charsToAdd;
      }
      isRendering = false;
    };
    let lastRenderTime = 0;
    const update = async (response, isFinal = false) => {
      if (response.actions && response.actions.length > 0) {
        toolContainer.empty();
        await this.renderToolActions(toolContainer, response.actions);
      }
      if (response.isThinking || response.thinkingText && response.thinkingText.length > 0) {
        thinkingContainer.style.display = "block";
        if (response.thinkingText && response.thinkingText.length > 0) {
          thinkingContent.style.display = "block";
          dotsContainer.style.display = "none";
          const targetText = response.thinkingText;
          const currentDisplayed = thinkingContent.innerText.length;
          if (targetText.length > currentDisplayed) {
            if (!typeWriterInterval) {
              typeWriterInterval = setInterval(() => {
                const current = thinkingContent.innerText;
                const target = fullThinkingText;
                if (current.length < target.length) {
                  const charsToAdd = Math.min(5, target.length - current.length);
                  thinkingContent.innerText = target.substring(0, current.length + charsToAdd);
                  thinkingContent.scrollTop = thinkingContent.scrollHeight;
                } else {
                  clearInterval(typeWriterInterval);
                  typeWriterInterval = null;
                }
              }, 20);
            }
          }
          fullThinkingText = targetText;
        } else {
          dotsContainer.style.display = "flex";
        }
        if (!response.isThinking && response.thinkingText) {
          thinkingContent.innerText = response.thinkingText;
          if (typeWriterInterval) {
            clearInterval(typeWriterInterval);
            typeWriterInterval = null;
          }
          dotsContainer.style.display = "none";
          thinkingContainer.addClass("thinking-code-block");
        }
      }
      if (response.text && response.text !== fullTextToRender) {
        fullTextToRender = response.text;
        const now = Date.now();
        if (isFinal || now - lastRenderTime > 20) {
          const tempContainer = createDiv();
          const component = new import_obsidian3.Component();
          component.load();
          await import_obsidian3.MarkdownRenderer.render(this.app, fullTextToRender, tempContainer, "", component);
          textContainer.empty();
          while (tempContainer.firstChild) {
            textContainer.appendChild(tempContainer.firstChild);
          }
          lastRenderTime = now;
        }
      }
      this.scrollBottom();
    };
    return { container: contentContainer, update };
  }
  async renderToolActions(container, actions) {
    if (!container)
      return;
    const actionContainer = container.createDiv("chat-tool-actions");
    for (const action of actions) {
      const toolCard = actionContainer.createDiv("tool-action-card");
      if (action.status === "error")
        toolCard.addClass("tool-error");
      const header = toolCard.createDiv("tool-header");
      const iconSpan = header.createSpan("tool-icon");
      if (action.tool === "run_terminal_command") {
        (0, import_obsidian3.setIcon)(iconSpan, "terminal-square");
      } else if (action.tool === "fetch_url") {
        (0, import_obsidian3.setIcon)(iconSpan, "link");
      } else if (action.tool === "google_search_retrieval") {
        (0, import_obsidian3.setIcon)(iconSpan, "globe");
      } else if (action.tool === "generate_image") {
        (0, import_obsidian3.setIcon)(iconSpan, "palette");
      } else {
        (0, import_obsidian3.setIcon)(iconSpan, "wrench");
      }
      const title = header.createSpan("tool-name");
      title.innerText = `Used ${action.tool}`;
      const details = toolCard.createDiv("tool-details");
      if (action.tool === "generate_image") {
        details.innerText = `Prompt: "${action.input.prompt}"`;
      } else if (action.tool === "create_note" || action.tool === "read_file") {
        details.innerText = action.input.path;
      } else if (action.tool === "search_content") {
        details.innerText = `"${action.input.query}"`;
      } else if (action.tool === "run_terminal_command") {
        details.createEl("code", { text: action.input.command, cls: "tool-input-code" });
      } else if (action.tool === "fetch_url") {
        details.innerText = action.input.url;
      } else {
        details.innerText = JSON.stringify(action.input);
      }
    }
  }
  renderThinking(container) {
    const thinkingContainer = container.createDiv("thinking-container");
    thinkingContainer.innerHTML = '<div class="thinking-dots"><div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div></div>';
    this.scrollBottom();
    return thinkingContainer;
  }
  scrollBottom() {
    this.container.scrollTop = this.container.scrollHeight;
  }
};

// src/views/ChatView.ts
var VIEW_TYPE_MASTERMIND = "mastermind-chat-view";
var MastermindChatView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.abortController = null;
    this.isGenerating = false;
    this.plugin = plugin;
    this.vertexService = new VertexService(plugin.settings);
    this.vaultService = new VaultService(this.app);
  }
  getViewType() {
    return VIEW_TYPE_MASTERMIND;
  }
  getDisplayText() {
    return "Mastermind AI";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("chat-view");
    this.toolbarEl = container.createDiv("chat-toolbar");
    const modelContainer = this.toolbarEl.createDiv("model-picker-container");
    this.modelLabel = modelContainer.createEl("span", {
      cls: "model-indicator"
    });
    this.modelLabel.innerText = this.plugin.settings.modelId || "gemini-2.0-flash-001";
    this.modelLabel.title = "Current Model (Click to Settings)";
    this.plugin.onSettingsChange(() => {
      if (this.modelLabel) {
        this.modelLabel.innerText = this.plugin.settings.modelId;
      }
    });
    this.modelLabel.onclick = () => {
      this.app.setting.open();
      this.app.setting.openTabById(this.plugin.manifest.id);
    };
    const actionsDiv = this.toolbarEl.createDiv({ cls: "toolbar-actions" });
    actionsDiv.style.display = "flex";
    actionsDiv.style.gap = "8px";
    const newChatBtn = actionsDiv.createEl("button", { cls: "toolbar-btn" });
    newChatBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg>`;
    newChatBtn.title = "New Conversation";
    newChatBtn.onclick = async () => {
      if (this.isGenerating) {
        new import_obsidian4.Notice("Please stop generation first.");
        return;
      }
      if (this.messages.length > 0) {
        if (!this.plugin.settings.history || !Array.isArray(this.plugin.settings.history)) {
          this.plugin.settings.history = [];
        }
        await this.plugin.saveSettings();
      }
      this.messages = [];
      this.renderMessages();
      new import_obsidian4.Notice("Started new conversation.");
    };
    const historyBtn = actionsDiv.createEl("button", { cls: "toolbar-btn" });
    historyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0z"/></svg>`;
    historyBtn.title = "History";
    historyBtn.onclick = () => {
      const savedConversations = this.plugin.settings.history || [];
      new import_obsidian4.Notice(`History contains ${savedConversations.length} items.`);
    };
    const settingsBtn = actionsDiv.createEl("button", { cls: "toolbar-btn" });
    settingsBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>`;
    settingsBtn.title = "Settings";
    settingsBtn.onclick = () => {
      this.app.setting.open();
      this.app.setting.openTabById(this.plugin.manifest.id);
    };
    this.messageContainer = container.createDiv("chat-messages");
    this.messageRenderer = new MessageRenderer(this.app, this.messageContainer);
    const inputWrapper = container.createDiv("chat-input-wrapper");
    const inputContainer = inputWrapper.createDiv("chat-input-container");
    const overlay = inputContainer.createDiv("chat-features-overlay");
    const icons = [
      {
        name: "file",
        svg: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>'
      },
      {
        name: "image",
        svg: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>'
      },
      {
        name: "mic",
        svg: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>'
      }
    ];
    icons.forEach((i) => {
      const btn = overlay.createEl("div", { cls: "feature-icon" });
      btn.innerHTML = i.svg;
      btn.onclick = () => new import_obsidian4.Notice(`${i.name} feature coming soon!`);
    });
    this.inputEl = inputContainer.createEl("textarea", {
      cls: "chat-input",
      attr: { rows: "1" }
      // Clean input, no placeholder
    });
    this.inputEl.addEventListener("input", () => {
      this.inputEl.style.height = "auto";
      this.inputEl.style.height = `${this.inputEl.scrollHeight}px`;
    });
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.handleSendMessage();
        this.inputEl.style.height = "auto";
      }
    });
    this.sendButton = inputContainer.createEl("button", {
      cls: "chat-send-button"
    });
    this.updateSendButton(false);
    this.sendButton.addEventListener("click", () => {
      if (this.isGenerating) {
        this.stopGeneration();
      } else {
        this.handleSendMessage();
      }
    });
    if (this.plugin.settings.history && this.plugin.settings.history.length > 0) {
      this.messages = [...this.plugin.settings.history];
    }
    this.renderMessages();
  }
  updateSendButton(isGenerating) {
    this.isGenerating = isGenerating;
    if (isGenerating) {
      this.sendButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="6" width="12" height="12"></rect></svg>';
      this.sendButton.title = "Stop Generating";
    } else {
      this.sendButton.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 2L11 13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 2L15 22L11 13L2 9L22 2Z" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      this.sendButton.title = "Send Message";
    }
  }
  stopGeneration() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
      new import_obsidian4.Notice("Generation stopped.");
      this.updateSendButton(false);
    }
  }
  renderMessages() {
    this.messageContainer.empty();
    this.messageRenderer.renderTo(this.messageContainer);
    if (this.messages.length === 0) {
      this.messageRenderer.renderAIMessage(
        "Greetings. I am Mastermind. How can I assist you in your vault today?",
        this.plugin.settings.profilePictureAI
      );
    } else {
      for (const msg of this.messages) {
        if (msg.role === "user") {
          this.messageRenderer.renderUserMessage(
            msg.parts[0].text,
            this.plugin.settings.profilePictureUser
          );
        } else {
          this.vaultService.enhanceTextWithLinks(msg.parts[0].text).then((enhancedText) => {
            this.messageRenderer.renderAIMessage(
              enhancedText,
              this.plugin.settings.profilePictureAI,
              msg.actions
            );
          });
        }
      }
    }
  }
  async handleSendMessage() {
    const message = this.inputEl.value.trim();
    if (!message)
      return;
    this.inputEl.value = "";
    this.updateSendButton(true);
    this.abortController = new AbortController();
    const signal = this.abortController.signal;
    await this.messageRenderer.renderUserMessage(
      message,
      this.plugin.settings.profilePictureUser
    );
    const { update } = this.messageRenderer.startAIMessage(
      this.plugin.settings.profilePictureAI
    );
    let finalResponse = {
      text: "",
      actions: []
    };
    try {
      this.vertexService.updateSettings(this.plugin.settings);
      const context = await this.vaultService.getRelevantContext(message);
      const images = await this.vaultService.getActiveNoteImages();
      for await (const chunk of this.vertexService.chat(
        message,
        context,
        this.vaultService,
        this.plugin.settings.history,
        images,
        signal
      )) {
        if (signal.aborted)
          break;
        await update(chunk, false);
        finalResponse = chunk;
      }
      if (!signal.aborted) {
        if (finalResponse.text) {
          const enhancedText = await this.vaultService.enhanceTextWithLinks(
            finalResponse.text
          );
          finalResponse.text = enhancedText;
          await update(finalResponse, true);
        }
        const userMsg = {
          role: "user",
          parts: [{ text: message }]
        };
        const aiMsg = {
          role: "model",
          parts: [{ text: finalResponse.text }],
          actions: finalResponse.actions
        };
        this.messages.push(userMsg);
        this.messages.push(aiMsg);
        this.plugin.settings.history.push(userMsg);
        this.plugin.settings.history.push(aiMsg);
        if (this.plugin.settings.history.length > 40) {
          this.plugin.settings.history = this.plugin.settings.history.slice(-40);
        }
        await this.plugin.saveSettings();
        await this.vaultService.writeHistory(
          this.plugin.settings.history,
          this.sessionId
        );
      }
    } catch (error) {
      if (error.name === "AbortError" || signal.aborted) {
        update(
          {
            text: `**[Stopped by User]**

${(finalResponse == null ? void 0 : finalResponse.text) || ""}`,
            actions: []
          },
          true
        );
      } else {
        console.error("Mastermind Error:", error);
        let errorMessage = error instanceof Error ? error.message : String(error);
        update({ text: `**Error**: ${errorMessage}`, actions: [] }, true);
        new import_obsidian4.Notice("Mastermind Chat failed.");
      }
    } finally {
      this.updateSendButton(false);
      this.abortController = null;
    }
  }
  async onClose() {
    this.stopGeneration();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  authProvider: "vertex",
  serviceAccountJson: "",
  aiStudioKey: "",
  location: "us-central1",
  modelId: "gemini-2.0-flash-001",
  history: [],
  permVaultRead: true,
  permVaultWrite: true,
  permVaultDelete: false,
  permWeb: true,
  permTerminal: false,
  confirmVaultDestructive: true,
  confirmTerminalDestructive: true,
  profilePictureUser: "https://api.dicebear.com/7.x/notionists/svg?seed=User",
  profilePictureAI: "https://api.dicebear.com/7.x/bottts/svg?seed=Mastermind",
  customContextPrompt: "",
  defaultModel: "gemini-2.0-flash-001",
  availableModels: [],
  maxOutputTokens: 8192,
  temperature: 0.7
};
var MastermindPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.settingsCallbacks = [];
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_MASTERMIND,
      (leaf) => new MastermindChatView(leaf, this)
    );
    this.addRibbonIcon("brain-circuit", "Mastermind AI", () => {
      this.activateView();
    });
    this.addSettingTab(new MastermindSettingTab(this.app, this));
    this.addCommand({
      id: "chat-active-note",
      name: "Chat with Active Note",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (!checking) {
            this.activateView();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "explain-selection",
      name: "Explain Selection",
      editorCallback: async (editor, view) => {
        const selection = editor.getSelection();
        if (selection) {
          await this.activateView();
          const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_MASTERMIND);
          if (leaves.length > 0) {
            const view2 = leaves[0].view;
            if (view2) {
              if (view2.inputEl) {
                view2.inputEl.value = `Explain this:
> ${selection}`;
                view2.handleSendMessage();
              }
            }
          }
        }
      }
    });
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_MASTERMIND)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_MASTERMIND,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadSettings() {
    var _a;
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const canListModels = this.settings.availableModels.length === 0 && (this.settings.authProvider === "vertex" && !!this.settings.serviceAccountJson || this.settings.authProvider === "aistudio" && !!this.settings.aiStudioKey);
    if (canListModels) {
      setTimeout(async () => {
        const vertex = new VertexService(this.settings);
        try {
          const models = await vertex.listModels();
          if (models.length > 0) {
            this.settings.availableModels = models;
            if (!models.includes(this.settings.modelId)) {
              this.settings.modelId = models[0];
            }
            await this.saveSettings();
            const providerLabel = this.settings.authProvider === "aistudio" ? "AI Studio" : "Vertex AI";
            new import_obsidian5.Notice(
              `Mastermind: Auto-fetched ${models.length} ${providerLabel} models.`
            );
          }
        } catch (e) {
          console.log("Mastermind: Auto-fetch failed silently.");
        }
      }, 2e3);
    } else if (this.settings.availableModels.length === 0) {
      const fallback = VertexService.getFallbackModelsFor(
        (_a = this.settings.authProvider) != null ? _a : "vertex"
      );
      this.settings.availableModels = fallback;
      if (!fallback.includes(this.settings.modelId) && fallback.length > 0) {
        this.settings.modelId = fallback[0];
      }
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.notifySettingsChanged();
  }
  onSettingsChange(callback) {
    this.settingsCallbacks.push(callback);
  }
  notifySettingsChanged() {
    this.settingsCallbacks.forEach((cb) => cb());
  }
};
var MastermindSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Mastermind Settings" });
    containerEl.createEl("h3", { text: "Authentication" });
    new import_obsidian5.Setting(containerEl).setName("Authentication Provider").setDesc(
      "Choose between Vertex AI (GCP Service Account) or AI Studio (API Key)."
    ).addDropdown(
      (dropdown) => dropdown.addOption("vertex", "Vertex AI (GCP)").addOption("aistudio", "AI Studio (API Key)").setValue(this.plugin.settings.authProvider).onChange(async (value) => {
        this.plugin.settings.authProvider = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.authProvider === "vertex") {
      if (this.plugin.settings.availableModels.length === 0 && this.plugin.settings.serviceAccountJson) {
        const vertex = new VertexService(this.plugin.settings);
        try {
          const models = await vertex.listModels();
          if (models.length > 0) {
            this.plugin.settings.availableModels = models;
          }
        } catch (e) {
          console.error("Mastermind: Display auto-fetch failed", e);
        }
      }
      new import_obsidian5.Setting(containerEl).setName("Service Account JSON").setDesc(
        "Paste the full content of your Google Cloud Service Account JSON key file."
      ).addTextArea(
        (text) => text.setPlaceholder('{"type": "service_account", ...}').setValue(this.plugin.settings.serviceAccountJson).onChange(async (value) => {
          this.plugin.settings.serviceAccountJson = value;
          await this.plugin.saveSettings();
        })
      );
      const locations = {
        Global: ["global"],
        US: ["us-central1", "us-east1", "us-east4", "us-west1", "us-west4"],
        Europe: [
          "europe-west1",
          "europe-west2",
          "europe-west3",
          "europe-west4",
          "europe-north1"
        ],
        Asia: ["asia-east1", "asia-northeast1", "asia-southeast1"]
      };
      new import_obsidian5.Setting(containerEl).setName("Vertex AI Region").setDesc("Select the Google Cloud region for API calls.").addDropdown((dropdown) => {
        for (const region in locations) {
          const locs = locations[region];
          locs.forEach(
            (loc) => dropdown.addOption(loc, `${region} - ${loc}`)
          );
        }
        dropdown.setValue(this.plugin.settings.location).onChange(async (value) => {
          this.plugin.settings.location = value;
          await this.plugin.saveSettings();
        });
      });
    } else {
      if (this.plugin.settings.availableModels.length === 0 && this.plugin.settings.aiStudioKey) {
        const vertex = new VertexService(this.plugin.settings);
        try {
          const models = await vertex.listModels();
          if (models.length > 0) {
            this.plugin.settings.availableModels = models;
          }
        } catch (e) {
          console.error("Mastermind: Display auto-fetch failed", e);
        }
      }
      new import_obsidian5.Setting(containerEl).setName("AI Studio API Key").setDesc("Enter your Google AI Studio API key.").addText(
        (text) => text.setPlaceholder("AIza...").setValue(this.plugin.settings.aiStudioKey).onChange(async (value) => {
          this.plugin.settings.aiStudioKey = value;
          await this.plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("h3", { text: "Model Selection" });
    new import_obsidian5.Setting(containerEl).setName("Gemini Model").setDesc("Select a supported Gemini model.").addDropdown((dropdown) => {
      const fallbackModels = VertexService.getFallbackModelsFor(
        this.plugin.settings.authProvider
      );
      const options = this.plugin.settings.availableModels.length > 0 ? this.plugin.settings.availableModels : [this.plugin.settings.modelId, ...fallbackModels];
      const uniqueOptions = [...new Set(options.filter(Boolean))];
      uniqueOptions.forEach((m) => dropdown.addOption(m, m));
      dropdown.setValue(this.plugin.settings.modelId);
      dropdown.onChange(async (value) => {
        this.plugin.settings.modelId = value;
        await this.plugin.saveSettings();
      });
      this.modelDropdown = dropdown;
    }).addExtraButton(
      (btn) => btn.setIcon("refresh-cw").setTooltip("Fetch accessible models").onClick(async () => {
        const vertex = new VertexService(this.plugin.settings);
        try {
          const btnEl = btn.extraSettingsEl;
          btnEl.addClass("is-loading");
          new import_obsidian5.Notice("Fetching models...");
          const models = await vertex.listModels();
          if (models.length > 0) {
            const dd = this.modelDropdown;
            dd.selectEl.innerHTML = "";
            models.forEach((m) => dd.addOption(m, m));
            dd.setValue(models[0]);
            this.plugin.settings.modelId = models[0];
            this.plugin.settings.availableModels = models;
            await this.plugin.saveSettings();
            new import_obsidian5.Notice(`Fetched ${models.length} models.`);
          } else {
            new import_obsidian5.Notice("No additional models found.");
          }
        } catch (e) {
          new import_obsidian5.Notice("Failed to fetch models.");
          console.error("Fetch error:", e);
        }
      })
    );
    containerEl.createEl("h3", { text: "Generation Parameters" });
    new import_obsidian5.Setting(containerEl).setName("Max Output Tokens").setDesc("Maximum number of tokens to generate (e.g., 8192).").addText(
      (text) => text.setValue(String(this.plugin.settings.maxOutputTokens)).onChange(async (value) => {
        const numeric = parseInt(value);
        if (!isNaN(numeric)) {
          this.plugin.settings.maxOutputTokens = numeric;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Temperature").setDesc("Creativity (0.0 - 2.0). Higher values = more creative.").addSlider(
      (slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.temperature = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Tool Permissions" });
    new import_obsidian5.Setting(containerEl).setName("Vault Read Access").setDesc("Allow AI to read files, search vault, list directories.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.permVaultRead).onChange(async (value) => {
        this.plugin.settings.permVaultRead = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Vault Write Access").setDesc("Allow AI to create notes, update sections, append content.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.permVaultWrite).onChange(async (value) => {
        this.plugin.settings.permVaultWrite = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Vault Delete Access").setDesc("Allow AI to delete files and folders.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.permVaultDelete).onChange(async (value) => {
        this.plugin.settings.permVaultDelete = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Web Access").setDesc("Allow AI to fetch URLs from the internet.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.permWeb).onChange(async (value) => {
        this.plugin.settings.permWeb = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Terminal Access").setDesc("Allow AI to run shell commands on your system.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.permTerminal).onChange(async (value) => {
        this.plugin.settings.permTerminal = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Safety Confirmations" });
    new import_obsidian5.Setting(containerEl).setName("Confirm Vault Deletions").setDesc("Ask before AI deletes files in your vault.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.confirmVaultDestructive).onChange(async (value) => {
        this.plugin.settings.confirmVaultDestructive = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Confirm Terminal Commands").setDesc("Ask before AI runs potentially destructive shell commands.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.confirmTerminalDestructive).onChange(async (value) => {
        this.plugin.settings.confirmTerminalDestructive = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Appearance & Behavior" });
    new import_obsidian5.Setting(containerEl).setName("Profile Picture (User)").setDesc("URL for your avatar.").addText(
      (text) => text.setPlaceholder("https://...").setValue(this.plugin.settings.profilePictureUser).onChange(async (value) => {
        this.plugin.settings.profilePictureUser = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Profile Picture (AI)").setDesc("URL for Mastermind's avatar.").addText(
      (text) => text.setPlaceholder("https://...").setValue(this.plugin.settings.profilePictureAI).onChange(async (value) => {
        this.plugin.settings.profilePictureAI = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Custom Context Prompt").setDesc('Additional instructions for the AI (e.g., "Be concise").').addTextArea(
      (text) => text.setPlaceholder("You are an expert coder...").setValue(this.plugin.settings.customContextPrompt).onChange(async (value) => {
        this.plugin.settings.customContextPrompt = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

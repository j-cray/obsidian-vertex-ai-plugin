/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MastermindPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/views/ChatView.ts
var import_obsidian4 = require("obsidian");

// src/services/vertex.ts
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var VertexService = class {
  constructor(settings) {
    this.customContextPrompt = "";
    this.accessToken = null;
    this.tokenExpiry = 0;
    this.isRefreshingToken = false;
    this.tokenRefreshPromise = null;
    this.updateSettings(settings);
  }
  updateSettings(settings) {
    this.serviceAccountJson = settings.serviceAccountJson;
    this.location = settings.location;
    this.modelId = settings.modelId;
    this.customContextPrompt = settings.customContextPrompt;
    this.accessToken = null;
  }
  async getAccessToken() {
    if (this.accessToken && Date.now() < this.tokenExpiry) {
      return this.accessToken;
    }
    if (!this.serviceAccountJson) {
      throw new Error("Service Account JSON not configured.");
    }
    let credentials;
    try {
      credentials = JSON.parse(this.serviceAccountJson);
    } catch (e) {
      throw new Error("Invalid Service Account JSON format.");
    }
    if (!credentials.client_email || !credentials.private_key) {
      throw new Error("Service Account JSON missing client_email or private_key.");
    }
    const token = await this.createSignedJWT(credentials.client_email, credentials.private_key);
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://oauth2.googleapis.com/token",
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${token}`
    });
    if (response.status !== 200) {
      throw new Error(`Failed to refresh token: ${response.text}`);
    }
    const data = response.json;
    this.accessToken = data.access_token;
    this.tokenExpiry = Date.now() + (data.expires_in - 60) * 1e3;
    return this.accessToken;
  }
  async createSignedJWT(email, privateKeyPem) {
    const header = { alg: "RS256", typ: "JWT" };
    const now = Math.floor(Date.now() / 1e3);
    const claim = {
      iss: email,
      scope: "https://www.googleapis.com/auth/cloud-platform",
      aud: "https://oauth2.googleapis.com/token",
      exp: now + 3600,
      iat: now
    };
    const encodedHeader = this.base64url(JSON.stringify(header));
    const encodedClaim = this.base64url(JSON.stringify(claim));
    const unsignedToken = `${encodedHeader}.${encodedClaim}`;
    const signature = await this.sign(unsignedToken, privateKeyPem);
    return `${unsignedToken}.${signature}`;
  }
  base64url(source) {
    let encodedSource;
    if (typeof source === "string") {
      const bytes = new TextEncoder().encode(source);
      encodedSource = this.arrayBufferToBase64(bytes);
    } else {
      encodedSource = this.arrayBufferToBase64(source);
    }
    return encodedSource.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }
  async sign(data, privateKeyPem) {
    const pemHeader = "-----BEGIN PRIVATE KEY-----";
    const pemFooter = "-----END PRIVATE KEY-----";
    const pemContents = privateKeyPem.substring(
      privateKeyPem.indexOf(pemHeader) + pemHeader.length,
      privateKeyPem.indexOf(pemFooter)
    ).replace(/\s/g, "");
    const binaryDerString = window.atob(pemContents);
    const binaryDer = new Uint8Array(binaryDerString.length);
    for (let i = 0; i < binaryDerString.length; i++) {
      binaryDer[i] = binaryDerString.charCodeAt(i);
    }
    const crypto = window.crypto.subtle;
    const key = await crypto.importKey(
      "pkcs8",
      binaryDer.buffer,
      {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-256"
      },
      false,
      ["sign"]
    );
    const encoder = new TextEncoder();
    const dataBytes = encoder.encode(data);
    const signature = await crypto.sign("RSASSA-PKCS1-v1_5", key, dataBytes);
    return this.base64url(signature);
  }
  getProjectId() {
    try {
      return JSON.parse(this.serviceAccountJson).project_id;
    } catch (e) {
      return "";
    }
  }
  getBaseUrl(location) {
    const host = location === "global" ? "aiplatform.googleapis.com" : `${location}-aiplatform.googleapis.com`;
    return `https://${host}/v1/projects/${this.getProjectId()}/locations/${location}`;
  }
  async listModels() {
    const accessToken = await this.getAccessToken();
    const projectId = JSON.parse(this.serviceAccountJson).project_id;
    const location = this.location || "us-central1";
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://${location}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${location}/models?filter=labels.google-cloud-model-garden=true&pageSize=100`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/json"
        }
      });
      if (response.status === 200) {
        const data = response.json;
        if (data.models && data.models.length > 0) {
          const fetched = data.models.map((m) => m.displayName).filter((name) => typeof name === "string");
          const unique = [...new Set(fetched)].sort();
          if (unique.length > 0) {
            return unique;
          }
          throw new Error("Vertex AI returned no models.");
        }
        throw new Error("Vertex AI returned no models.");
      }
      throw new Error(`Vertex AI listModels failed with status ${response.status}`);
    } catch (error) {
      console.error("Mastermind: Failed to list models via API.", error);
      throw error;
    }
  }
  async chat(prompt, context, vaultService, history = [], images = []) {
    var _a;
    const accessToken = await this.getAccessToken();
    const projectId = JSON.parse(this.serviceAccountJson).project_id;
    const modelId = this.modelId || "gemini-2.0-flash-exp";
    const isClaude = modelId.startsWith("claude");
    const isEndpoint = /^\d+$/.test(modelId) || modelId.includes("/endpoints/");
    const location = this.location || "us-central1";
    if (isEndpoint) {
      const endpointResource = modelId.includes("/") ? modelId : `projects/${projectId}/locations/${location}/endpoints/${modelId}`;
      const url2 = `https://${location}-aiplatform.googleapis.com/v1/${endpointResource}:predict`;
      const body = {
        instances: [
          {
            prompt: `System: You are Mastermind.
Context: ${context}

User: ${prompt}
Assistant:`
            // Some models treat "messages" list differently.
            // For broad compatibility with raw endpoints, we construct a single prompt string.
            // Ideally, we'd detect the model type, but for "generic endpoint" support, text completion is safest default.
          }
        ],
        parameters: {
          temperature: 0.7,
          maxOutputTokens: 2048,
          topP: 0.95
        }
      };
      const response = await (0, import_obsidian.requestUrl)({
        url: url2,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      if (response.status !== 200) {
        throw new Error(`Endpoint Error ${response.status}: ${response.text}`);
      }
      const data = response.json;
      const pred = data.predictions[0];
      if (typeof pred === "string")
        return pred;
      if (pred.content)
        return pred.content;
      return JSON.stringify(pred);
    }
    if (isClaude) {
      const url2 = `https://${location}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${location}/publishers/anthropic/models/${modelId}:streamRawPredict`;
      const messages = history.map((h) => ({
        role: h.role === "model" ? "assistant" : "user",
        content: h.parts[0].text
        // Simplify: previous parts usually just text
      }));
      messages.push({ role: "user", content: `Context:
${context}

Question: ${prompt}` });
      const body = {
        anthropic_version: "vertex-2023-10-16",
        messages,
        system: `You are Mastermind. ${this.customContextPrompt || ""} Be concise.`,
        max_tokens: 4096,
        stream: false
      };
      const response = await (0, import_obsidian.requestUrl)({
        url: url2,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Content-Type": "application/json; charset=utf-8"
        },
        body: JSON.stringify(body)
      });
      if (response.status !== 200) {
        throw new Error(`Claude API Error ${response.status}: ${response.text}`);
      }
      const data = response.json;
      return data.content ? data.content[0].text : JSON.stringify(data);
    }
    const url = `https://${location}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${location}/publishers/google/models/${modelId}:generateContent`;
    let systemInstructionText = `You are "Mastermind", a highly capable AI assistant for Obsidian.
You have access to the user's notes and knowledge vault.
Be concise, professional, and insightful.
Always use the provided context to answer questions if available.
You can use tools to search, read, list, create, and delete notes/folders in the vault.

IMPORTANT: If you need to reason through a complex problem, show your work by wrapping your thought process in a "thinking" code block, like this:
\`\`\`thinking
My reasoning process...
\`\`\`
Then provide your final answer.`;
    if (this.customContextPrompt) {
      systemInstructionText += `

USER CUSTOM INSTRUCTIONS:
${this.customContextPrompt}`;
    }
    const tools = [
      {
        function_declarations: [
          {
            name: "list_files",
            description: "Lists all markdown files in the vault.",
            parameters: { type: "object", properties: {} }
          },
          {
            name: "list_directory",
            description: "Lists the contents of a specific directory/folder.",
            parameters: {
              type: "object",
              properties: {
                path: { type: "string", description: "The path of the folder to list." }
              },
              required: ["path"]
            }
          },
          {
            name: "list_directory",
            description: "Lists the contents of a specific directory/folder.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The path of the folder to list."
                }
              },
              required: ["path"]
            }
          },
          {
            name: "read_file",
            description: "Reads the full content of a specified markdown file.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The absolute path of the file to read."
                }
              },
              required: ["path"]
            }
          },
          {
            name: "search_content",
            description: "Searches for a keyword or phrase within all markdown files in the vault.",
            parameters: {
              type: "object",
              properties: {
                query: { type: "string", description: "The search term." }
              },
              required: ["query"]
            }
          },
          {
            name: "create_note",
            description: "Creates a new markdown note with the specified content.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: 'The path for the new note (e.g., "Summaries/MyNote.md").'
                },
                content: {
                  type: "string",
                  description: "The content of the note."
                }
              },
              required: ["path", "content"]
            }
          },
          {
            name: "create_folder",
            description: "Creates a new folder.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The path for the new folder."
                }
              },
              required: ["path"]
            }
          },
          {
            name: "delete_file",
            description: "Deletes a file or folder. Use with caution.",
            parameters: {
              type: "object",
              properties: {
                path: {
                  type: "string",
                  description: "The path of the file to delete."
                }
              },
              required: ["path"]
            }
          }
        ]
      }
    ];
    let contents = [...history];
    const parts = [{ text: `Context from vault:
${context}

User Question: ${prompt}` }];
    for (const img of images) {
      parts.push({
        inlineData: {
          mimeType: img.mimeType,
          data: img.data
        }
      });
    }
    contents.push({ role: "user", parts });
    for (let i = 0; i < 5; i++) {
      const body = {
        contents,
        system_instruction: { parts: [{ text: systemInstructionText }] },
        tools,
        generationConfig: { temperature: 0.7, maxOutputTokens: 2048 }
      };
      const response = await (0, import_obsidian.requestUrl)({
        url,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${accessToken}`
        },
        body: JSON.stringify(body)
      });
      if (response.status !== 200) {
        throw new Error(`Vertex AI Error ${response.status}: ${response.text}`);
      }
      const data = response.json;
      if (!data.candidates || data.candidates.length === 0) {
        if ((_a = data.promptFeedback) == null ? void 0 : _a.blockReason) {
          throw new Error(`Blocked: ${data.promptFeedback.blockReason}`);
        }
        throw new Error("No candidates returned from Vertex AI.");
      }
      const candidate = data.candidates[0];
      if (candidate.finishReason === "SAFETY") {
        throw new Error("Response blocked due to safety settings.");
      }
      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
        throw new Error("Received empty content from Vertex AI.");
      }
      const part = candidate.content.parts[0];
      if (part.functionCall) {
        const funcCall = part.functionCall;
        const { name, args } = funcCall;
        let result;
        try {
          if (name === "list_files") {
            result = await vaultService.listMarkdownFiles();
          } else if (name === "read_file") {
            result = await vaultService.getFileContent(args.path);
          } else if (name === "search_content") {
            result = await vaultService.searchVault(args.query);
          } else if (name === "create_note") {
            await vaultService.createNote(args.path, args.content);
            result = { status: "success", message: `Note created at ${args.path}` };
          } else if (name === "create_folder") {
            await vaultService.createFolder(args.path);
            result = { status: "success", message: `Folder created at ${args.path}` };
          } else if (name === "delete_file") {
            await vaultService.deleteFile(args.path);
            result = { status: "success", message: `File deleted at ${args.path}` };
          } else if (name === "list_directory") {
            result = await vaultService.listDirectory(args.path);
          }
        } catch (err) {
          result = { status: "error", message: err.message };
        }
        contents.push(candidate.content);
        contents.push({
          role: "function",
          parts: [{
            functionResponse: {
              name,
              response: { name, content: result }
            }
          }]
        });
      } else {
        return part.text;
      }
    }
    throw new Error("Maximum tool use iterations reached.");
  }
  // Helper method to validate JSON
  validateJSON(json) {
    try {
      JSON.parse(json);
      return true;
    } catch (e) {
      return false;
    }
  }
};

// src/services/vault.ts
var import_obsidian2 = require("obsidian");
var VaultService = class {
  constructor(app) {
    this.app = app;
  }
  async getRelevantContext(query) {
    const activeFile = this.app.workspace.getActiveFile();
    let context = "";
    if (activeFile) {
      const content = await this.app.vault.read(activeFile);
      context += `--- ACTIVE FILE: ${activeFile.path} ---
${content}

`;
    }
    const files = this.app.vault.getMarkdownFiles();
    const queryLower = query.toLowerCase();
    const scores = await Promise.all(files.map(async (file) => {
      let score = 0;
      if (file.name.toLowerCase().includes(queryLower))
        score += 10;
      if (file.path.toLowerCase().includes(queryLower))
        score += 5;
      const content = await this.app.vault.read(file);
      const contentSnippet = content.substring(0, 5e3).toLowerCase();
      if (contentSnippet.includes(queryLower))
        score += 20;
      return { file, score };
    }));
    const relevantFiles = scores.filter((item) => item.score > 5).sort((a, b) => b.score - a.score).slice(0, 5);
    for (const item of relevantFiles) {
      if (item.file.path === (activeFile == null ? void 0 : activeFile.path))
        continue;
      const content = await this.app.vault.read(item.file);
      context += `--- RELEVANT FILE: ${item.file.path} ---
${content.substring(0, 2e3)}...

`;
    }
    return context || "No immediate relevant context found. Mastermind may need to search the vault.";
  }
  async listMarkdownFiles() {
    return this.app.vault.getMarkdownFiles().map((f) => f.path);
  }
  async getFileContent(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian2.TFile) {
      return await this.app.vault.read(file);
    }
    throw new Error(`File not found or not a markdown file: ${path}`);
  }
  async getActiveNoteImages() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile)
      return [];
    const content = await this.app.vault.read(activeFile);
    const imageExtensions = ["png", "jpg", "jpeg", "gif", "webp"];
    const images = [];
    const wikilinkRegex = /!\[\[([^\]]+\.(?:png|jpg|jpeg|gif|webp))\]\]/gi;
    const mdlinkRegex = /!\[(?:[^\]]*)\]\(([^)]+\.(?:png|jpg|jpeg|gif|webp))\)/gi;
    const findImages = async (regex, content2) => {
      let match;
      while ((match = regex.exec(content2)) !== null) {
        const link = match[1];
        const file = this.app.metadataCache.getFirstLinkpathDest(link, activeFile.path);
        if (file instanceof import_obsidian2.TFile && imageExtensions.includes(file.extension.toLowerCase())) {
          const buffer = await this.app.vault.readBinary(file);
          const base64 = this.arrayBufferToBase64(buffer);
          const mimeType = `image/${file.extension === "jpg" ? "jpeg" : file.extension}`;
          images.push({ mimeType, data: base64 });
        }
      }
    };
    await findImages(wikilinkRegex, content);
    await findImages(mdlinkRegex, content);
    return images;
  }
  arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
  }
  async searchVault(query) {
    const queryLower = query.toLowerCase();
    const files = this.app.vault.getMarkdownFiles();
    const results = [];
    for (const file of files) {
      const content = await this.app.vault.read(file);
      if (content.toLowerCase().includes(queryLower) || file.path.toLowerCase().includes(queryLower)) {
        results.push(file.path);
      }
      if (results.length >= 20)
        break;
    }
    return results;
  }
  async createFolder(path) {
    if (!await this.app.vault.adapter.exists(path)) {
      await this.app.vault.createFolder(path);
    }
  }
  async createNote(path, content) {
    const normalizedPath = path.endsWith(".md") ? path : `${path}.md`;
    const folders = normalizedPath.split("/").slice(0, -1);
    if (folders.length > 0) {
      const folderPath = folders.join("/");
      await this.ensureFoldersExist(folderPath);
    }
    if (await this.app.vault.adapter.exists(normalizedPath)) {
      const file = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (file instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(file, content);
        return;
      }
    }
    await this.app.vault.create(normalizedPath, content);
  }
  async ensureFoldersExist(path) {
    const dirs = path.split("/");
    let currentPath = "";
    for (const dir of dirs) {
      currentPath = currentPath === "" ? dir : `${currentPath}/${dir}`;
      if (!await this.app.vault.adapter.exists(currentPath)) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  async deleteFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file) {
      await this.app.vault.delete(file, true);
    } else {
      throw new Error(`File to delete not found: ${path}`);
    }
  }
  async getAllFileNames() {
    const files = this.app.vault.getMarkdownFiles();
    const fileNames = /* @__PURE__ */ new Set();
    for (const file of files) {
      if (file.basename) {
        fileNames.add(file.basename);
      }
    }
    return fileNames;
  }
  async writeHistory(history, sessionId) {
    const historyFolder = "Mastermind/History";
    await this.ensureFoldersExist(historyFolder);
    let filename = sessionId;
    if (!filename) {
      const now = new Date();
      filename = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")}-${String(now.getHours()).padStart(2, "0")}-${String(now.getMinutes()).padStart(2, "0")}-${String(now.getSeconds()).padStart(2, "0")}`;
    }
    if (!filename.endsWith(".md"))
      filename += ".md";
    const path = `${historyFolder}/${filename}`;
    let content = "# Mastermind Conversation\n\n";
    history.forEach((msg) => {
      const role = msg.role === "user" ? "User" : "Mastermind";
      const text = msg.parts.map((p) => p.text).join("\n");
      content += `> **${role}**
${text}

`;
    });
    content += `
*Auto-saved at ${new Date().toISOString()}*`;
    await this.createOrUpdateNote(path, content);
    return filename.replace(".md", "");
  }
  async listFolder(path) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (!folder || !folder.children) {
      throw new Error(`Folder not found: ${path}`);
    }
    return folder.children.map((child) => child.path);
  }
  async moveFile(oldPath, newPath) {
    const file = this.app.vault.getAbstractFileByPath(oldPath);
    if (!file) {
      throw new Error(`File or folder not found: ${oldPath}`);
    }
    const folders = newPath.split("/").slice(0, -1);
    if (folders.length > 0) {
      await this.ensureFoldersExist(folders.join("/"));
    }
    if (await this.app.vault.adapter.exists(newPath)) {
      throw new Error(`A file or folder already exists at the destination path: ${newPath}`);
    }
    await this.app.vault.rename(file, newPath);
  }
  // Improved Implementation: createOrUpdateNote
  async createOrUpdateNote(path, content) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(file, content);
    } else {
      const lastSlash = path.lastIndexOf("/");
      if (lastSlash !== -1) {
        await this.ensureFoldersExist(path.substring(0, lastSlash));
      }
      await this.app.vault.create(path, content);
    }
  }
  async writeLog(message) {
    const logPath = "Mastermind/Logs/debug.md";
    let currentContent = "";
    try {
      currentContent = await this.getFileContent(logPath);
    } catch (e) {
      currentContent = "# Mastermind Debug Logs\n\n";
    }
    const timestamp = new Date().toISOString();
    const newContent = `${currentContent}
[${timestamp}] ${message}
`;
    await this.createOrUpdateNote(logPath, newContent);
  }
  async saveImage(base64Data) {
    const folder = "Mastermind_Images";
    await this.ensureFoldersExist(folder);
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const filename = `Generated-${timestamp}.png`;
    const filepath = `${folder}/${filename}`;
    const buffer = this.base64ToArrayBuffer(base64Data);
    if (await this.app.vault.adapter.exists(filepath)) {
    }
    await this.app.vault.createBinary(filepath, buffer);
    return `![Generated Image](${filepath})`;
  }
  base64ToArrayBuffer(base64) {
    const binaryString = window.atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
  async enhanceTextWithLinks(text) {
    const fileNames = await this.getAllFileNames();
    const sortedNames = Array.from(fileNames).sort((a, b) => b.length - a.length);
    let processedText = text;
    for (const name of sortedNames) {
      if (name.length < 3)
        continue;
      const regex = new RegExp(`(?<!\\[\\[)\\b(${this.escapeRegExp(name)})\\b(?!\\]\\])`, "g");
      processedText = processedText.replace(regex, "[[$1]]");
    }
    return processedText;
  }
  async appendToNote(path, content) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.process(file, (data) => {
        return data + ((data.endsWith("\n") ? "" : "\n") + content);
      });
    } else {
      throw new Error(`File not found: ${path}`);
    }
  }
  async prependToNote(path, content) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian2.TFile) {
      await this.app.vault.process(file, (data) => {
        const frontmatterRegex = /^---\n[\s\S]*?\n---\n/;
        const match = data.match(frontmatterRegex);
        if (match) {
          return data.slice(0, match[0].length) + content + "\n" + data.slice(match[0].length);
        } else {
          return content + "\n" + data;
        }
      });
    } else {
      throw new Error(`File not found: ${path}`);
    }
  }
  async updateNoteSection(path, header, newContent) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian2.TFile))
      throw new Error(`File not found: ${path}`);
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.headings)
      throw new Error(`No metadata/headings found for ${path}`);
    const targetHeading = cache.headings.find((h) => h.heading === header);
    if (!targetHeading)
      throw new Error(`Heading "${header}" not found in ${path}`);
    const headings = cache.headings;
    const targetIndex = headings.indexOf(targetHeading);
    let endLine = -1;
    for (let i = targetIndex + 1; i < headings.length; i++) {
      if (headings[i].level <= targetHeading.level) {
        endLine = headings[i].position.start.line;
        break;
      }
    }
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const startLine = targetHeading.position.end.line + 1;
    const actualEndLine = endLine === -1 ? lines.length : endLine;
    const newLines = [
      ...lines.slice(0, startLine),
      newContent,
      ...lines.slice(actualEndLine)
    ];
    await this.app.vault.modify(file, newLines.join("\n"));
  }
  async getTags() {
    const tags = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache) {
        const fileTags = (0, import_obsidian2.getAllTags)(cache);
        if (fileTags) {
          fileTags.forEach((t) => tags.add(t));
        }
      }
    }
    return Array.from(tags).sort();
  }
  async getLinks(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian2.TFile))
      throw new Error(`File not found: ${path}`);
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache || !cache.links)
      return [];
    return cache.links.map((l) => l.link);
  }
  // Helper for internal use if needed
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};

// src/views/MessageRenderer.ts
var import_obsidian3 = require("obsidian");
var MessageRenderer = class {
  constructor(app, container) {
    this.app = app;
    this.container = container;
  }
  renderTo(container) {
    this.container = container;
  }
  async renderUserMessage(text, avatarUrl) {
    const msgBlock = this.container.createDiv("chat-message-block message-block-user");
    const avatar = msgBlock.createEl("img", { cls: "chat-avatar", attr: { src: avatarUrl } });
    const msgEl = msgBlock.createDiv("chat-message message-user");
    msgEl.innerText = text;
    this.scrollBottom();
    return msgEl;
  }
  async renderAIMessage(text, avatarUrl, actions = []) {
    const msgBlock = this.container.createDiv("chat-message-block message-block-ai");
    const avatar = msgBlock.createEl("img", { cls: "chat-avatar", attr: { src: avatarUrl } });
    const contentContainer = msgBlock.createDiv("chat-message-content message-ai");
    if (actions && actions.length > 0) {
      await this.renderToolActions(contentContainer, actions);
    }
    if (text) {
      const msgEl = contentContainer.createDiv("chat-text-content");
      const component = new import_obsidian3.Component();
      component.load();
      await import_obsidian3.MarkdownRenderer.render(this.app, text, msgEl, "", component);
    }
    this.scrollBottom();
    return contentContainer;
  }
  startAIMessage(avatarUrl) {
    const msgBlock = this.container.createDiv("chat-message-block message-block-ai");
    const avatar = msgBlock.createEl("img", { cls: "chat-avatar", attr: { src: avatarUrl } });
    const contentContainer = msgBlock.createDiv("chat-message-content message-ai");
    const toolContainer = contentContainer.createDiv("chat-tool-actions");
    const thinkingContainer = contentContainer.createDiv("thinking-container");
    thinkingContainer.style.display = "none";
    const thinkingHeader = thinkingContainer.createDiv("thinking-header");
    (0, import_obsidian3.setIcon)(thinkingHeader.createSpan("thinking-icon"), "brain-circuit");
    thinkingHeader.createSpan().innerText = "Thinking Process";
    const dotsContainer = thinkingContainer.createDiv("thinking-dots");
    dotsContainer.innerHTML = '<div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div>';
    const thinkingContent = thinkingContainer.createDiv("thinking-content");
    thinkingContent.style.display = "none";
    const textContainer = contentContainer.createDiv("chat-text-content");
    let fullTextToRender = "";
    let fullThinkingText = "";
    let displayedTextLength = 0;
    let isRendering = false;
    let typeWriterInterval = null;
    const processTypewriterQueue = async () => {
      if (isRendering)
        return;
      isRendering = true;
      const targetLength = fullTextToRender.length;
      if (displayedTextLength < targetLength) {
        const backlog = targetLength - displayedTextLength;
        const charsToAdd = backlog > 50 ? 5 : backlog > 20 ? 2 : 1;
        const nextChunk = fullTextToRender.substring(displayedTextLength, displayedTextLength + charsToAdd);
        displayedTextLength += charsToAdd;
      }
      isRendering = false;
    };
    let lastRenderTime = 0;
    const update = async (response, isFinal = false) => {
      if (response.actions && response.actions.length > 0) {
        toolContainer.empty();
        await this.renderToolActions(toolContainer, response.actions);
      }
      if (response.isThinking || response.thinkingText && response.thinkingText.length > 0) {
        thinkingContainer.style.display = "block";
        if (response.thinkingText && response.thinkingText.length > 0) {
          thinkingContent.style.display = "block";
          dotsContainer.style.display = "none";
          const targetText = response.thinkingText;
          const currentDisplayed = thinkingContent.innerText.length;
          if (targetText.length > currentDisplayed) {
            if (!typeWriterInterval) {
              typeWriterInterval = setInterval(() => {
                const current = thinkingContent.innerText;
                const target = fullThinkingText;
                if (current.length < target.length) {
                  const charsToAdd = Math.min(5, target.length - current.length);
                  thinkingContent.innerText = target.substring(0, current.length + charsToAdd);
                  thinkingContent.scrollTop = thinkingContent.scrollHeight;
                } else {
                  clearInterval(typeWriterInterval);
                  typeWriterInterval = null;
                }
              }, 20);
            }
          }
          fullThinkingText = targetText;
        } else {
          dotsContainer.style.display = "flex";
        }
        if (!response.isThinking && response.thinkingText) {
          thinkingContent.innerText = response.thinkingText;
          if (typeWriterInterval) {
            clearInterval(typeWriterInterval);
            typeWriterInterval = null;
          }
          dotsContainer.style.display = "none";
          thinkingContainer.addClass("thinking-code-block");
        }
      }
      if (response.text && response.text !== fullTextToRender) {
        fullTextToRender = response.text;
        const now = Date.now();
        if (isFinal || now - lastRenderTime > 20) {
          const tempContainer = createDiv();
          const component = new import_obsidian3.Component();
          component.load();
          await import_obsidian3.MarkdownRenderer.render(this.app, fullTextToRender, tempContainer, "", component);
          textContainer.empty();
          while (tempContainer.firstChild) {
            textContainer.appendChild(tempContainer.firstChild);
          }
          lastRenderTime = now;
        }
      }
      this.scrollBottom();
    };
    return { container: contentContainer, update };
  }
  async renderToolActions(container, actions) {
    if (!container)
      return;
    const actionContainer = container.createDiv("chat-tool-actions");
    for (const action of actions) {
      const toolCard = actionContainer.createDiv("tool-action-card");
      if (action.status === "error")
        toolCard.addClass("tool-error");
      const header = toolCard.createDiv("tool-header");
      const iconSpan = header.createSpan("tool-icon");
      if (action.tool === "run_terminal_command") {
        (0, import_obsidian3.setIcon)(iconSpan, "terminal-square");
      } else if (action.tool === "fetch_url") {
        (0, import_obsidian3.setIcon)(iconSpan, "link");
      } else if (action.tool === "google_search_retrieval") {
        (0, import_obsidian3.setIcon)(iconSpan, "globe");
      } else if (action.tool === "generate_image") {
        (0, import_obsidian3.setIcon)(iconSpan, "palette");
      } else {
        (0, import_obsidian3.setIcon)(iconSpan, "wrench");
      }
      const title = header.createSpan("tool-name");
      title.innerText = `Used ${action.tool}`;
      const details = toolCard.createDiv("tool-details");
      if (action.tool === "generate_image") {
        details.innerText = `Prompt: "${action.input.prompt}"`;
      } else if (action.tool === "create_note" || action.tool === "read_file") {
        details.innerText = action.input.path;
      } else if (action.tool === "search_content") {
        details.innerText = `"${action.input.query}"`;
      } else if (action.tool === "run_terminal_command") {
        details.createEl("code", { text: action.input.command, cls: "tool-input-code" });
      } else if (action.tool === "fetch_url") {
        details.innerText = action.input.url;
      } else {
        details.innerText = JSON.stringify(action.input);
      }
    }
  }
  renderThinking(container) {
    const thinkingContainer = container.createDiv("thinking-container");
    thinkingContainer.innerHTML = '<div class="thinking-dots"><div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div></div>';
    this.scrollBottom();
    return thinkingContainer;
  }
  scrollBottom() {
    this.container.scrollTop = this.container.scrollHeight;
  }
};

// src/views/ChatView.ts
var VIEW_TYPE_MASTERMIND = "mastermind-chat-view";
var MastermindChatView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.abortController = null;
    this.isGenerating = false;
    this.plugin = plugin;
    this.vertexService = new VertexService(plugin.settings);
    this.vaultService = new VaultService(this.app);
  }
  getViewType() {
    return VIEW_TYPE_MASTERMIND;
  }
  getDisplayText() {
    return "Mastermind AI";
  }
  getIcon() {
    return "brain-circuit";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("chat-view");
    this.toolbarEl = container.createDiv("chat-toolbar");
    const modelContainer = this.toolbarEl.createDiv("model-picker-container");
    this.modelLabel = modelContainer.createEl("span", { cls: "model-indicator" });
    this.modelLabel.innerText = this.plugin.settings.modelId || "gemini-2.0-flash-exp";
    this.modelLabel.title = "Current Model (Click to Settings)";
    this.plugin.onSettingsChange(() => {
      if (this.modelLabel) {
        this.modelLabel.innerText = this.plugin.settings.modelId;
      }
    });
    this.modelLabel.onclick = () => {
      this.app.setting.open();
      this.app.setting.openTabById(this.plugin.manifest.id);
    };
    const actionsDiv = this.toolbarEl.createDiv({ cls: "toolbar-actions" });
    actionsDiv.style.display = "flex";
    actionsDiv.style.gap = "8px";
    const newChatBtn = actionsDiv.createEl("button", { cls: "toolbar-btn" });
    newChatBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg>`;
    newChatBtn.title = "New Conversation";
    newChatBtn.onclick = async () => {
      if (this.isGenerating) {
        new import_obsidian4.Notice("Please stop generation first.");
        return;
      }
      if (this.messages.length > 0) {
        if (!this.plugin.settings.history || !Array.isArray(this.plugin.settings.history)) {
          this.plugin.settings.history = [];
        }
        await this.plugin.saveSettings();
      }
      this.messages = [];
      this.renderMessages();
      new import_obsidian4.Notice("Started new conversation.");
    };
    const historyBtn = actionsDiv.createEl("button", { cls: "toolbar-btn" });
    historyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0z"/></svg>`;
    historyBtn.title = "History";
    historyBtn.onclick = () => {
      const savedConversations = this.plugin.settings.history || [];
      new import_obsidian4.Notice(`History contains ${savedConversations.length} items.`);
    };
    const settingsBtn = actionsDiv.createEl("button", { cls: "toolbar-btn" });
    settingsBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>`;
    settingsBtn.title = "Settings";
    settingsBtn.onclick = () => {
      this.app.setting.open();
      this.app.setting.openTabById(this.plugin.manifest.id);
    };
    this.messageContainer = container.createDiv("chat-messages");
    this.messageRenderer = new MessageRenderer(this.app, this.messageContainer);
    const inputWrapper = container.createDiv("chat-input-wrapper");
    const inputContainer = inputWrapper.createDiv("chat-input-container");
    const overlay = inputContainer.createDiv("chat-features-overlay");
    const icons = [
      {
        name: "file",
        svg: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>'
      },
      {
        name: "image",
        svg: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>'
      },
      {
        name: "mic",
        svg: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>'
      }
    ];
    icons.forEach((i) => {
      const btn = overlay.createEl("div", { cls: "feature-icon" });
      btn.innerHTML = i.svg;
      btn.onclick = () => new import_obsidian4.Notice(`${i.name} feature coming soon!`);
    });
    this.inputEl = inputContainer.createEl("textarea", {
      cls: "chat-input",
      attr: { rows: "1" }
      // Clean input, no placeholder
    });
    this.inputEl.addEventListener("input", () => {
      this.inputEl.style.height = "auto";
      this.inputEl.style.height = `${this.inputEl.scrollHeight}px`;
    });
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.handleSendMessage();
        this.inputEl.style.height = "auto";
      }
    });
    this.sendButton = inputContainer.createEl("button", { cls: "chat-send-button" });
    this.updateSendButton(false);
    this.sendButton.addEventListener("click", () => {
      if (this.isGenerating) {
        this.stopGeneration();
      } else {
        this.handleSendMessage();
      }
    });
    if (this.plugin.settings.history && this.plugin.settings.history.length > 0) {
      this.messages = [...this.plugin.settings.history];
    }
    this.renderMessages();
  }
  updateSendButton(isGenerating) {
    this.isGenerating = isGenerating;
    if (isGenerating) {
      this.sendButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="6" width="12" height="12"></rect></svg>';
      this.sendButton.title = "Stop Generating";
    } else {
      this.sendButton.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M22 2L11 13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 2L15 22L11 13L2 9L22 2Z" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
      this.sendButton.title = "Send Message";
    }
  }
  stopGeneration() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
      new import_obsidian4.Notice("Generation stopped.");
      this.updateSendButton(false);
    }
  }
  renderMessages() {
    this.messageContainer.empty();
    this.messageRenderer.renderTo(this.messageContainer);
    if (this.messages.length === 0) {
      this.messageRenderer.renderAIMessage("Greetings. I am Mastermind. How can I assist you in your vault today?", this.plugin.settings.profilePictureAI);
    } else {
      for (const msg of this.messages) {
        if (msg.role === "user") {
          this.messageRenderer.renderUserMessage(msg.parts[0].text, this.plugin.settings.profilePictureUser);
        } else {
          this.vaultService.enhanceTextWithLinks(msg.parts[0].text).then((enhancedText) => {
            this.messageRenderer.renderAIMessage(enhancedText, this.plugin.settings.profilePictureAI, msg.actions);
          });
        }
      }
    }
  }
  async handleSendMessage() {
    const message = this.inputEl.value.trim();
    if (!message)
      return;
    this.inputEl.value = "";
    this.updateSendButton(true);
    this.abortController = new AbortController();
    const signal = this.abortController.signal;
    await this.messageRenderer.renderUserMessage(message, this.plugin.settings.profilePictureUser);
    const { update } = this.messageRenderer.startAIMessage(this.plugin.settings.profilePictureAI);
    let finalResponse = { text: "", actions: [] };
    try {
      this.vertexService.updateSettings(this.plugin.settings);
      const context = await this.vaultService.getRelevantContext(message);
      const images = await this.vaultService.getActiveNoteImages();
      for await (const chunk of this.vertexService.chat(message, context, this.vaultService, this.plugin.settings.history, images, signal)) {
        if (signal.aborted)
          break;
        await update(chunk, false);
        finalResponse = chunk;
      }
      if (!signal.aborted) {
        if (finalResponse.text) {
          const enhancedText = await this.vaultService.enhanceTextWithLinks(finalResponse.text);
          finalResponse.text = enhancedText;
          await update(finalResponse, true);
        }
        const userMsg = { role: "user", parts: [{ text: message }] };
        const aiMsg = {
          role: "model",
          parts: [{ text: finalResponse.text }],
          actions: finalResponse.actions
        };
        this.messages.push(userMsg);
        this.messages.push(aiMsg);
        this.plugin.settings.history.push(userMsg);
        this.plugin.settings.history.push(aiMsg);
        if (this.plugin.settings.history.length > 40) {
          this.plugin.settings.history = this.plugin.settings.history.slice(-40);
        }
        await this.plugin.saveSettings();
        await this.vaultService.writeHistory(this.plugin.settings.history, this.sessionId);
      }
    } catch (error) {
      if (error.name === "AbortError" || signal.aborted) {
        update({ text: `**[Stopped by User]**

${(finalResponse == null ? void 0 : finalResponse.text) || ""}`, actions: [] }, true);
      } else {
        console.error("Mastermind Error:", error);
        let errorMessage = error instanceof Error ? error.message : String(error);
        update({ text: `**Error**: ${errorMessage}`, actions: [] }, true);
        new import_obsidian4.Notice("Mastermind Chat failed.");
      }
    } finally {
      this.updateSendButton(false);
      this.abortController = null;
    }
  }
  async onClose() {
    this.stopGeneration();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  authProvider: "vertex",
  serviceAccountJson: "",
  aiStudioKey: "",
  location: "us-central1",
  modelId: "gemini-2.0-flash-exp",
  history: [],
  permVaultRead: true,
  permVaultWrite: true,
  permVaultDelete: false,
  permWeb: true,
  permTerminal: false,
  confirmVaultDestructive: true,
  confirmTerminalDestructive: true,
  profilePictureUser: "https://api.dicebear.com/7.x/notionists/svg?seed=User",
  profilePictureAI: "https://api.dicebear.com/7.x/bottts/svg?seed=Mastermind",
  customContextPrompt: "",
  defaultModel: "gemini-2.0-flash-exp",
  availableModels: [],
  maxOutputTokens: 8192,
  temperature: 0.7
};
var MastermindPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.settingsCallbacks = [];
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_MASTERMIND,
      (leaf) => new MastermindChatView(leaf, this)
    );
    this.addRibbonIcon("brain-circuit", "Mastermind AI", () => {
      this.activateView();
    });
    this.addSettingTab(new MastermindSettingTab(this.app, this));
    this.addCommand({
      id: "chat-active-note",
      name: "Chat with Active Note",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (!checking) {
            this.activateView();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "explain-selection",
      name: "Explain Selection",
      editorCallback: async (editor, view) => {
        const selection = editor.getSelection();
        if (selection) {
          await this.activateView();
          const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_MASTERMIND);
          if (leaves.length > 0) {
            const view2 = leaves[0].view;
            if (view2) {
              if (view2.inputEl) {
                view2.inputEl.value = `Explain this:
> ${selection}`;
                view2.handleSendMessage();
              }
            }
          }
        }
      }
    });
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_MASTERMIND)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_MASTERMIND,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const canListModels = this.settings.availableModels.length === 0 && (this.settings.authProvider === "vertex" && !!this.settings.serviceAccountJson || this.settings.authProvider === "aistudio" && !!this.settings.aiStudioKey);
    if (canListModels) {
      setTimeout(async () => {
        const vertex = new VertexService(this.settings);
        try {
          const models = await vertex.listModels();
          if (models.length > 0) {
            this.settings.availableModels = models;
            if (!models.includes(this.settings.modelId)) {
              this.settings.modelId = models[0];
            }
            await this.saveSettings();
            const providerLabel = this.settings.authProvider === "aistudio" ? "AI Studio" : "Vertex AI";
            new import_obsidian5.Notice(
              `Mastermind: Auto-fetched ${models.length} ${providerLabel} models.`
            );
          } else {
            new import_obsidian5.Notice("Mastermind: Model list was empty. Check account permissions.");
          }
        } catch (e) {
          console.error("Mastermind: Failed to auto-fetch models.", e);
          new import_obsidian5.Notice("Mastermind: Failed to fetch models. Check credentials or network.");
        }
      }, 2e3);
    } else if (this.settings.availableModels.length === 0) {
      console.log("Mastermind: Model list unavailable; configure credentials to fetch available models.");
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.notifySettingsChanged();
  }
  onSettingsChange(callback) {
    this.settingsCallbacks.push(callback);
  }
  notifySettingsChanged() {
    this.settingsCallbacks.forEach((cb) => cb());
  }
};
var MastermindSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Mastermind Settings" });
    containerEl.createEl("h3", { text: "Authentication" });
    new import_obsidian5.Setting(containerEl).setName("Authentication Provider").setDesc("Choose between Vertex AI (GCP Service Account) or AI Studio (API Key).").addDropdown((dropdown) => dropdown.addOption("vertex", "Vertex AI (GCP)").addOption("aistudio", "AI Studio (API Key)").setValue(this.plugin.settings.authProvider).onChange(async (value) => {
      this.plugin.settings.authProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.authProvider === "vertex") {
      if (this.plugin.settings.serviceAccountJson && this.plugin.settings.availableModels.length === 0) {
        const vertex = new VertexService(this.plugin.settings);
        try {
          const models = await vertex.listModels();
          if (models.length > 0) {
            this.plugin.settings.availableModels = models;
          }
        } catch (e) {
          console.error("Mastermind: Display auto-fetch failed", e);
        }
      }
      new import_obsidian5.Setting(containerEl).setName("Service Account JSON").setDesc("Paste the full content of your Google Cloud Service Account JSON key file.").addTextArea((text) => text.setPlaceholder('{"type": "service_account", ...}').setValue(this.plugin.settings.serviceAccountJson).onChange(async (value) => {
        this.plugin.settings.serviceAccountJson = value;
        await this.plugin.saveSettings();
      }));
      const locations = {
        "Global": ["global"],
        "US": ["us-central1", "us-east1", "us-east4", "us-west1", "us-west4"],
        "Europe": ["europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-north1"],
        "Asia": ["asia-east1", "asia-northeast1", "asia-southeast1"]
      };
      new import_obsidian5.Setting(containerEl).setName("Vertex AI Region").setDesc("Select the Google Cloud region for API calls.").addDropdown((dropdown) => {
        for (const region in locations) {
          const locs = locations[region];
          locs.forEach((loc) => dropdown.addOption(loc, `${region} - ${loc}`));
        }
        dropdown.setValue(this.plugin.settings.location).onChange(async (value) => {
          this.plugin.settings.location = value;
          await this.plugin.saveSettings();
        });
      });
    } else {
      new import_obsidian5.Setting(containerEl).setName("AI Studio API Key").setDesc("Enter your Google AI Studio API key.").addText((text) => text.setPlaceholder("AIza...").setValue(this.plugin.settings.aiStudioKey).onChange(async (value) => {
        this.plugin.settings.aiStudioKey = value;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Model Selection" });
    new import_obsidian5.Setting(containerEl).setName("Gemini Model").setDesc("Select a supported Gemini model.").addDropdown((dropdown) => {
      const options = this.plugin.settings.availableModels.length > 0 ? this.plugin.settings.availableModels : [this.plugin.settings.modelId, "gemini-2.0-flash-exp", "gemini-1.5-pro", "gemini-1.5-flash"];
      const uniqueOptions = [...new Set(options)];
      uniqueOptions.forEach((m) => dropdown.addOption(m, m));
      dropdown.setValue(this.plugin.settings.modelId);
      dropdown.onChange(async (value) => {
        this.plugin.settings.modelId = value;
        await this.plugin.saveSettings();
      });
      this.modelDropdown = dropdown;
    }).addExtraButton((btn) => btn.setIcon("refresh-cw").setTooltip("Fetch accessible models").onClick(async () => {
      const vertex = new VertexService(this.plugin.settings);
      try {
        const btnEl = btn.extraSettingsEl;
        btnEl.addClass("is-loading");
        new import_obsidian5.Notice("Fetching models...");
        const models = await vertex.listModels();
        if (models.length > 0) {
          const dd = this.modelDropdown;
          dd.selectEl.innerHTML = "";
          models.forEach((m) => dd.addOption(m, m));
          dd.setValue(models[0]);
          this.plugin.settings.modelId = models[0];
          this.plugin.settings.availableModels = models;
          await this.plugin.saveSettings();
          new import_obsidian5.Notice(`Fetched ${models.length} models.`);
        } else {
          new import_obsidian5.Notice("No additional models found.");
        }
      } catch (e) {
        new import_obsidian5.Notice("Failed to fetch models.");
        console.error("Fetch error:", e);
      }
    }));
    containerEl.createEl("h3", { text: "Generation Parameters" });
    new import_obsidian5.Setting(containerEl).setName("Max Output Tokens").setDesc("Maximum number of tokens to generate (e.g., 8192).").addText((text) => text.setValue(String(this.plugin.settings.maxOutputTokens)).onChange(async (value) => {
      const numeric = parseInt(value);
      if (!isNaN(numeric)) {
        this.plugin.settings.maxOutputTokens = numeric;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian5.Setting(containerEl).setName("Temperature").setDesc("Creativity (0.0 - 2.0). Higher values = more creative.").addSlider((slider) => slider.setLimits(0, 2, 0.1).setValue(this.plugin.settings.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.temperature = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Tool Permissions" });
    new import_obsidian5.Setting(containerEl).setName("Vault Read Access").setDesc("Allow AI to read files, search vault, list directories.").addToggle((toggle) => toggle.setValue(this.plugin.settings.permVaultRead).onChange(async (value) => {
      this.plugin.settings.permVaultRead = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Vault Write Access").setDesc("Allow AI to create notes, update sections, append content.").addToggle((toggle) => toggle.setValue(this.plugin.settings.permVaultWrite).onChange(async (value) => {
      this.plugin.settings.permVaultWrite = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Vault Delete Access").setDesc("Allow AI to delete files and folders.").addToggle((toggle) => toggle.setValue(this.plugin.settings.permVaultDelete).onChange(async (value) => {
      this.plugin.settings.permVaultDelete = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Web Access").setDesc("Allow AI to fetch URLs from the internet.").addToggle((toggle) => toggle.setValue(this.plugin.settings.permWeb).onChange(async (value) => {
      this.plugin.settings.permWeb = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Terminal Access").setDesc("Allow AI to run shell commands on your system.").addToggle((toggle) => toggle.setValue(this.plugin.settings.permTerminal).onChange(async (value) => {
      this.plugin.settings.permTerminal = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Safety Confirmations" });
    new import_obsidian5.Setting(containerEl).setName("Confirm Vault Deletions").setDesc("Ask before AI deletes files in your vault.").addToggle((toggle) => toggle.setValue(this.plugin.settings.confirmVaultDestructive).onChange(async (value) => {
      this.plugin.settings.confirmVaultDestructive = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Confirm Terminal Commands").setDesc("Ask before AI runs potentially destructive shell commands.").addToggle((toggle) => toggle.setValue(this.plugin.settings.confirmTerminalDestructive).onChange(async (value) => {
      this.plugin.settings.confirmTerminalDestructive = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Appearance & Behavior" });
    new import_obsidian5.Setting(containerEl).setName("Vault Read Access").setDesc("Allow AI to read files, search vault, list directories.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.permVaultRead).onChange(async (value) => {
        this.plugin.settings.permVaultRead = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Vault Write Access").setDesc("Allow AI to create notes, update sections, append content.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.permVaultWrite).onChange(async (value) => {
        this.plugin.settings.permVaultWrite = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Custom Context Prompt").setDesc('Additional instructions for the AI (e.g., "Be concise").').addTextArea((text) => text.setPlaceholder("You are an expert coder...").setValue(this.plugin.settings.customContextPrompt).onChange(async (value) => {
      this.plugin.settings.customContextPrompt = value;
      await this.plugin.saveSettings();
    }));
  }
};
